{
  "version": 3,
  "sources": ["../../path-to-regexp/src/index.ts", "../../atomic-router/src/methods/create-route.ts", "../../atomic-router/src/utils/equals.ts", "../../atomic-router/src/utils/build-path.ts", "../../atomic-router/src/utils/history-effects.ts", "../../atomic-router/src/utils/logic.ts", "../../atomic-router/src/methods/new-create-history-router.ts", "../../atomic-router/src/utils/remap-route-objects.ts", "../../atomic-router/src/methods/redirect.ts", "../../atomic-router/src/methods/chain-route.ts", "../../atomic-router/src/methods/query-sync.ts", "../../atomic-router/src/types.ts", "../../atomic-router/src/methods/create-router-controls.ts", "../../atomic-router/src/methods/is-route.ts"],
  "sourcesContent": ["/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "import {\n  attach,\n  createEffect,\n  createEvent,\n  createStore,\n  split,\n  Store,\n} from 'effector';\nimport {\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n  RouteInstance,\n  NavigateParams,\n  Kind,\n  EmptyObject,\n} from '../types';\n\ntype CreateRouteParams = {\n  filter?: Store<boolean>;\n};\n\nexport function createRoute<Params extends RouteParams = {}>(\n  params: CreateRouteParams = {}\n): RouteInstance<Params> {\n  const navigateFx = createEffect<\n    NavigateParams<Params>,\n    NavigateParams<Params>\n  >(({ params, query, replace = false }) => ({\n    params: params || {},\n    query: query || {},\n    replace,\n  }));\n\n  const openFx = attach({\n    effect: navigateFx,\n    mapParams: (params: Params extends EmptyObject ? void : Params) => ({\n      params: (params || {}) as Params,\n      query: {} as RouteQuery,\n    }),\n  });\n\n  const $isOpened = createStore<boolean>(false);\n  const $params = createStore<Params>({} as Params);\n  const $query = createStore<RouteQuery>({});\n\n  const opened = createEvent<RouteParamsAndQuery<Params>>();\n  const updated = createEvent<RouteParamsAndQuery<Params>>();\n  const closed = createEvent<void>();\n\n  $isOpened.on(opened, () => true).on(closed, () => false);\n\n  $params\n    .on(opened, (_, { params }) => params)\n    .on(updated, (_, { params }) => params);\n\n  $query\n    .on(opened, (_, { query }) => query)\n    .on(updated, (_, { query }) => query);\n\n  split({\n    source: navigateFx.doneData,\n    match: $isOpened.map((isOpened) => (isOpened ? 'updated' : 'opened')),\n    cases: {\n      opened,\n      updated,\n    },\n  });\n\n  // if (params.filter) {\n  //   const filter = params.filter;\n  //   split({\n  //     // @ts-expect-error\n  //     source: sample({ clock: filter }),\n  //     // @ts-expect-error\n  //     match: (filter) => (filter ? 'true' : 'false'),\n  //     cases: {\n  //       true: opened,\n  //       false: closed,\n  //     },\n  //   });\n  // }\n\n  const instance: RouteInstance<Params> = {\n    $isOpened,\n    $params,\n    $query,\n    opened,\n    updated,\n    closed,\n    navigate: navigateFx,\n    open: openFx,\n    kind: Kind.ROUTE,\n    // @ts-expect-error Internal stuff\n    settings: {\n      derived: Boolean(params.filter),\n    },\n  };\n\n  return instance;\n}\n", "export function paramsEqual(a: Record<string, any>, b: Record<string, any>) {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const k in a) {\n    // NOTE: Parsed URI always returns string parameters\n    // so we force string comparison here\n    // in order to avoid extra updates\n    // whenever user passes numeric params\n    if (`${a[k]}` !== `${b[k]}`) {\n      return false;\n    }\n  }\n  return true;\n}\n", "import { match, compile } from 'path-to-regexp';\n\nimport {\n  RouteParams,\n  PathCreator,\n  RouteQuery,\n  ParamsSerializer,\n} from '../types';\n\n// NOTE: If path is URL - provide it as is\n// Otherwise - extract pathname and hash\nconst getComparablePath = (path: string) => {\n  if (path.match(/^[a-z0-9]+\\:\\/\\//i)) {\n    return path;\n  }\n  const url = new URL(`http://_${path}`);\n  return [url.pathname, url.hash].join('');\n};\n\n// NOTE: path-to-regexp treats \":\" in \"https://\" as param start\n// So we escape it\nfunction normalizePathCreator(pathCreator: string) {\n  return pathCreator.replace('://', '\\\\://');\n}\n\ntype BuildPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  params: Params;\n  query: RouteQuery;\n  serialize?: ParamsSerializer;\n};\nexport function buildPath<Params extends RouteParams>({\n  pathCreator,\n  params,\n  query,\n  serialize,\n}: BuildPathParams<Params>) {\n  const pathname = compile(pathCreator)(params);\n  const serializedParams =\n    serialize?.write(query) ?? new URLSearchParams(query);\n  const qs = Object.keys(query).length ? `?${serializedParams}` : '';\n  const url = `${pathname}${qs}`;\n  return url;\n}\n\ntype MatchPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  actualPath: string;\n};\nexport function matchPath<Params extends RouteParams>({\n  pathCreator,\n  actualPath,\n}: MatchPathParams<Params>) {\n  const matches = match(normalizePathCreator(pathCreator))(\n    getComparablePath(actualPath)\n  );\n  if (matches) {\n    return { matches: true, params: matches.params } as const;\n  }\n  return { matches: false } as const;\n}\n", "import { History } from 'history';\nimport { createEffect } from 'effector';\n\nimport { HistoryBackForwardParams, HistoryPushParams } from '../types';\n\nfunction assertHistory(history: History) {\n  if (!history) {\n    throw new Error('[Routing] No history provided');\n  }\n}\n\nexport const historyPushFx = createEffect((params: HistoryPushParams) => {\n  assertHistory(params.history);\n  params.history[params.method](params.path, {});\n  return params;\n});\n\nexport const historyBackFx = createEffect(\n  (history: HistoryBackForwardParams) => {\n    assertHistory(history);\n    history.back();\n    return history;\n  }\n);\n\nexport const historyForwardFx = createEffect(\n  (history: HistoryBackForwardParams) => {\n    assertHistory(history);\n    history.forward();\n    return history;\n  }\n);\n", "import { Store } from 'effector';\n\nexport function not<T>(source: Store<T>): Store<boolean> {\n  return source.map((value) => !value);\n}\n", "import { History } from 'history';\nimport { attach, createEvent, createStore, sample, scopeBind } from 'effector';\nimport { createRouterControls } from './create-router-controls';\nimport {\n  HistoryPushParams,\n  ParamsSerializer,\n  RouteInstance,\n  RouteObject,\n  RouteParams,\n  RouteQuery,\n  UnmappedRouteObject,\n} from '../types';\nimport { remapRouteObjects } from '../utils/remap-route-objects';\nimport { paramsEqual } from '../utils/equals';\nimport { buildPath, matchPath } from '../utils/build-path';\nimport { isRoute } from './is-route';\nimport {\n  historyBackFx,\n  historyForwardFx,\n  historyPushFx,\n} from '../utils/history-effects';\nimport { not } from '../utils/logic';\n\nexport function createHistoryRouter({\n  base,\n  routes,\n  notFoundRoute,\n  hydrate,\n  serialize,\n  controls = createRouterControls(),\n}: {\n  base?: string;\n  routes: UnmappedRouteObject<any>[];\n  notFoundRoute?: RouteInstance<any>;\n  serialize?: ParamsSerializer;\n  hydrate?: boolean;\n  controls?: ReturnType<typeof createRouterControls>;\n}) {\n  const remappedRoutes = remapRouteObjects(routes, base);\n\n  const setHistory = createEvent<History>();\n  const navigateFromRouteTriggered = createEvent<{\n    route: RouteObject<any>;\n    params: RouteParams;\n    query: RouteQuery;\n    replace: boolean;\n  }>();\n  const historyUpdated = createEvent();\n  const recalculateTriggered = createEvent<{\n    path: string;\n    query: RouteQuery;\n    hash: string;\n  }>();\n  const recalculated = createEvent<{\n    path: string;\n    query: RouteQuery;\n    matching: RecalculationResult<any>[];\n    mismatching: RecalculationResult<any>[];\n  }>();\n  const routesMatched = createEvent<RecalculationResult<any>[]>();\n  const routesMismatched = createEvent<RecalculationResult<any>[]>();\n  const routeNotFound = createEvent();\n  const initialized = createEvent<{\n    activeRoutes: RouteInstance<any>[];\n    path: string;\n    query: RouteQuery;\n  }>();\n\n  const $path = createStore('');\n  const $query = createStore<RouteQuery>(\n    {},\n    {\n      name: 'historyRouter.$query',\n      updateFilter: (newQuery, oldQuery) => !paramsEqual(newQuery, oldQuery),\n    }\n  );\n  const $activeRoutes = createStore<RouteInstance<any>[]>([], {\n    serialize: 'ignore',\n  });\n  // @ts-expect-error\n  const $history = createStore<History>(null, {\n    serialize: 'ignore',\n  });\n  const $isFirstCheckPassed = createStore(false);\n  const $isRouteNavigateInProgress = createStore(false);\n\n  const pushFx = attach({\n    source: $history,\n    effect(history, params: Omit<HistoryPushParams, 'history'>) {\n      return historyPushFx({\n        history,\n        ...params,\n      });\n    },\n  });\n\n  const subscribeHistoryFx = attach({\n    source: $history,\n    effect(history) {\n      let scopedHistoryUpdated = historyUpdated;\n      try {\n        // @ts-expect-error\n        scopedHistoryUpdated = scopeBind(historyUpdated);\n      } catch (err) {}\n      history.listen(() => {\n        scopedHistoryUpdated();\n      });\n      return true;\n    },\n  });\n\n  const historyUpdatedParsed = sample({\n    clock: hydrate\n      ? [historyUpdated]\n      : [historyUpdated, subscribeHistoryFx.done],\n    source: $history,\n    filter: Boolean,\n    fn: (history) => ({\n      path: history.location.pathname,\n      query:\n        serialize?.read(history.location.search) ??\n        Object.fromEntries(new URLSearchParams(history.location.search)),\n    }),\n  });\n\n  // If `hydrate` flag is set,\n  // don't trigger recheck on history init\n  const historyUpdateTriggered = sample({\n    clock: historyUpdatedParsed,\n    source: {\n      path: $path,\n      query: $query,\n    },\n    filter: ({ path: savedPath, query: savedQuery }, history) =>\n      history.path !== savedPath || !paramsEqual(history.query, savedQuery),\n    fn: (_, history) => history,\n  });\n\n  /// History subscription\n  $history.on(setHistory, (_, history) => history);\n\n  sample({\n    clock: $history,\n    target: subscribeHistoryFx,\n  });\n\n  sample({\n    clock: historyUpdateTriggered,\n    source: $history,\n    filter: Boolean,\n    fn(history) {\n      const path = history?.location.pathname;\n      const hash = history?.location.hash;\n      const query: RouteQuery =\n        serialize?.read(history?.location.search) ??\n        Object.fromEntries(new URLSearchParams(history?.location.search));\n      return { path, query, hash };\n    },\n    target: recalculateTriggered,\n  });\n\n  /// Routes updates handling\n  for (const routeObj of remappedRoutes) {\n    const currentRouteMatched = routesMatched.filterMap(\n      containsCurrentRoute(routeObj)\n    );\n    const currentRouteMismatched = routesMismatched.filterMap(\n      containsCurrentRoute(routeObj)\n    );\n    const routeStateChangeRequested = {\n      opened: sample({\n        clock: currentRouteMatched,\n        filter: not(routeObj.route.$isOpened),\n      }),\n      updated: sample({\n        clock: currentRouteMatched,\n        filter: routeObj.route.$isOpened,\n      }),\n      closed: sample({\n        clock: currentRouteMismatched,\n        filter: routeObj.route.$isOpened,\n      }),\n    };\n\n    // Trigger .updated() for the routes marked as \"matched\" but already opened\n    sample({\n      clock: routeStateChangeRequested.updated,\n      source: [routeObj.route.$params, routeObj.route.$query],\n      // Skip .updated() calls if params & query are the same\n      filter: ([params, query], next) =>\n        !paramsEqual(params, next.params) || !paramsEqual(query, next.query),\n      fn: (_, paramsAndQuery) => paramsAndQuery,\n      target: routeObj.route.updated,\n    });\n\n    // Trigger .opened() for the routes marked as \"matched\" but not opened yet\n    sample({\n      clock: routeStateChangeRequested.opened,\n      // TODO: Scratch this?\n      filter: not($isRouteNavigateInProgress),\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .closed() for the routes marked as \"mismatched\" but opened\n    sample({\n      clock: routeStateChangeRequested.closed,\n      target: routeObj.route.closed,\n    });\n  }\n\n  /// Handling route.navigateFx navigation\n  for (const routeObj of remappedRoutes) {\n    // Run \"Handling route.navigateFx navigation\" step\n    sample({\n      clock: routeObj.route.navigate.doneData,\n      fn: ({ params, query, replace }) => ({\n        route: routeObj,\n        params,\n        query,\n        replace: replace ?? false,\n      }),\n      target: navigateFromRouteTriggered,\n    });\n  }\n\n  $isRouteNavigateInProgress.on(navigateFromRouteTriggered, () => true);\n\n  sample({\n    clock: navigateFromRouteTriggered,\n    fn({ route, params, query, replace }) {\n      const path = buildPath({\n        pathCreator: route.path,\n        params,\n        query,\n        serialize,\n      });\n      const method: 'replace' | 'push' = replace ? 'replace' : 'push';\n      return {\n        path,\n        params,\n        query,\n        method,\n      };\n    },\n    target: pushFx,\n  });\n\n  $isRouteNavigateInProgress.reset([routesMatched, routesMismatched]);\n\n  /// Recalculation\n  // Triggered on every history change + once when history instance is set\n  sample({\n    clock: recalculateTriggered,\n    fn({ path, query, hash }) {\n      const matchingRoutes = [] as RecalculationResult<any>[];\n      const mismatchingRoutes = [] as RecalculationResult<any>[];\n\n      for (const route of remappedRoutes) {\n        // NOTE: Use hash string as well if route.path contains #\n        const actualPath = route.path.includes('#')\n          ? `${path}${hash}`\n          : `${path}`;\n        const { matches, params } = matchPath({\n          pathCreator: route.path,\n          actualPath,\n        });\n\n        const suitableRoutes = matches ? matchingRoutes : mismatchingRoutes;\n        suitableRoutes.push({\n          routeObj: route,\n          params,\n          query,\n        });\n      }\n\n      // Checking for routes we need to close\n      // Remove all that are marked to be opened\n      mismatchingRoutes.forEach((mismatchedRoute, mismatchedIndex) => {\n        const mismatchedRouteExistsInMatchedList = matchingRoutes.some(\n          (matchedRoute) =>\n            matchedRoute.routeObj.route === mismatchedRoute.routeObj.route\n        );\n        if (mismatchedRouteExistsInMatchedList) {\n          mismatchingRoutes.splice(mismatchedIndex, 1);\n        }\n      });\n\n      return {\n        matching: matchingRoutes,\n        mismatching: mismatchingRoutes.filter(Boolean),\n        path,\n        query,\n      };\n    },\n    target: recalculated,\n  });\n\n  $path.on(historyUpdateTriggered, (_, { path }) => path);\n\n  $query.on(historyUpdateTriggered, (_, { query }) => query);\n\n  const matchingRecalculated = recalculated.map(({ matching }) => matching);\n\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length > 0,\n    target: routesMatched,\n  });\n\n  sample({\n    clock: recalculated.map(({ mismatching }) => mismatching),\n    filter: (routes) => routes.length > 0,\n    target: routesMismatched,\n  });\n\n  $activeRoutes.on(recalculated, (_, { matching }) =>\n    matching.map((recheckResult) => recheckResult.routeObj.route)\n  );\n\n  /// Handling 404\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length === 0,\n    target: routeNotFound,\n  });\n\n  if (isRoute(notFoundRoute)) {\n    sample({\n      clock: routeNotFound,\n      source: $query,\n      filter: notFoundRoute.$isOpened,\n      fn: (query) => ({ query, params: {} }),\n      target: notFoundRoute.updated,\n    });\n\n    sample({\n      clock: routeNotFound,\n      source: { query: $query, isOpened: notFoundRoute.$isOpened },\n      filter: ({ isOpened }) => !isOpened,\n      fn: ({ query }) => ({ query, params: {} }),\n      target: notFoundRoute.opened,\n    });\n\n    sample({\n      clock: matchingRecalculated,\n      source: notFoundRoute.$isOpened,\n      filter: (isOpened, matching) => isOpened && matching.length > 0,\n      target: notFoundRoute.closed,\n    });\n  }\n\n  /// Back/forward navigation\n  sample({\n    clock: controls.back,\n    source: $history,\n    target: historyBackFx,\n  });\n\n  sample({\n    clock: controls.forward,\n    source: $history,\n    target: historyForwardFx,\n  });\n\n  /// Query syncing\n  sample({\n    clock: $query,\n    source: { controlsQuery: controls.$query, localQuery: $query },\n    filter: ({ controlsQuery, localQuery }) =>\n      !paramsEqual(controlsQuery, localQuery),\n    fn: ({ localQuery }) => localQuery,\n    target: controls.$query,\n  });\n\n  sample({\n    clock: controls.$query,\n    source: {\n      path: $path,\n      localQuery: $query,\n      isNavigateInProgress: $isRouteNavigateInProgress,\n      realHistory: $history,\n    },\n    filter: ({ localQuery, isNavigateInProgress, realHistory }, query) => {\n      const realQuery =\n        serialize?.read(realHistory?.location.search ?? '') ??\n        Object.fromEntries(\n          new URLSearchParams(realHistory?.location.search ?? '')\n        );\n      return (\n        isNavigateInProgress ||\n        !paramsEqual(query, realQuery) ||\n        !paramsEqual(localQuery, query)\n      );\n    },\n    fn({ path }, query) {\n      const qs = serialize?.write(query) ?? new URLSearchParams(query);\n      return {\n        path: `${path}${qs ? `?${qs}` : ''}`,\n        params: {},\n        query: query,\n        method: 'push' as const,\n      };\n    },\n    target: pushFx,\n  });\n\n  /// Initialization\n  sample({\n    clock: recalculated,\n    source: {\n      activeRoutes: $activeRoutes,\n      path: $path,\n      query: $query,\n    },\n    filter: $isFirstCheckPassed.map(\n      (isFirstCheckPassed) => !isFirstCheckPassed\n    ),\n    target: initialized,\n  });\n\n  $isFirstCheckPassed.on(initialized, () => true).reset($history);\n\n  return {\n    $path,\n    $activeRoutes,\n    $history,\n    setHistory,\n    $query: $query,\n    back: controls.back,\n    forward: controls.forward,\n    push: pushFx,\n    routes: remappedRoutes,\n    initialized,\n    routeNotFound,\n  };\n}\n\ntype RecalculationResult<Params extends RouteParams> = {\n  routeObj: RouteObject<Params>;\n  params: Params;\n  query: RouteQuery;\n};\n\nconst containsCurrentRoute =\n  (routeObj: RouteObject<any>) =>\n  (recheckResults: RecalculationResult<any>[]) => {\n    const recheck = recheckResults.find(\n      (recheckResult) => recheckResult.routeObj.route === routeObj.route\n    );\n    if (!recheck) {\n      return;\n    }\n    return {\n      params: recheck.params,\n      query: recheck.query,\n    };\n  };\n", "import { UnmappedRouteObject, RouteObject } from '../types';\n\nexport function remapRouteObjects(\n  objects: UnmappedRouteObject<any>[],\n  basePath: string = ''\n) {\n  let next: RouteObject<any>[] = [];\n  for (const routeObj of objects) {\n    if (Array.isArray(routeObj.route)) {\n      next.push(...routeObj.route.map((route) => ({ ...routeObj, route })));\n    } else {\n      // @ts-expect-error\n      next.push(routeObj);\n    }\n  }\n  next = next.map((routeObj) => ({\n    ...routeObj,\n    path: `${basePath}${routeObj.path}`,\n  }));\n  const derivedRoutes: RouteObject<any>[] = [];\n  const nonDerivedRoutes: RouteObject<any>[] = [];\n  for (const routeObj of next) {\n    // @ts-expect-error Internals\n    if (routeObj.route.settings.derived) {\n      derivedRoutes.push(routeObj);\n    } else {\n      nonDerivedRoutes.push(routeObj);\n    }\n  }\n  if (derivedRoutes.length) {\n    for (const derivedRoute of derivedRoutes) {\n      console.error(\n        `createHistoryRouter: ${derivedRoute.path} uses derived route. This won't work`\n      );\n    }\n  }\n  return nonDerivedRoutes;\n}\n", "import {\n  Clock,\n  createEvent,\n  createStore,\n  Event,\n  is,\n  sample,\n  Store,\n} from 'effector';\nimport { EmptyObject, RouteInstance, RouteParams, RouteQuery } from '../types';\n\ntype RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject\n  ? {\n      clock?: Clock<T>;\n      route: RouteInstance<Params>;\n      query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n      replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n    }\n  :\n      | {\n          clock?: Clock<T>;\n          route: RouteInstance<Params>;\n          params: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        }\n      | {\n          clock?: Clock<{\n            params: Params;\n            query?: RouteQuery;\n            replace?: boolean;\n          }>;\n          route: RouteInstance<Params>;\n          params?: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        };\n\n/** Opens passed `route` upon `clock` trigger */\nexport function redirect<T, Params extends RouteParams>(\n  options: RedirectParams<T, Params>\n) {\n  const clock = options.clock\n    ? sample({ clock: options.clock as Event<T> })\n    : createEvent<T>();\n\n  let params = toStore(options.params || {});\n  let query = toStore(options.query || {});\n  // @ts-expect-error\n  let replace = toStore(options.replace || false);\n\n  sample({\n    clock: clock,\n    source: { params, query, replace },\n    fn: ({ params, query, replace }, clock) => ({\n      params: typeof params === 'function' ? params(clock) : params,\n      query: typeof query === 'function' ? query(clock) : query,\n      replace: typeof replace === 'function' ? replace(clock) : replace,\n    }),\n    target: options.route.navigate,\n  });\n  return clock;\n}\n\nfunction toStore<T>(payload: T | Store<T>): Store<T> {\n  return is.store(payload) ? payload : createStore(payload as T);\n}\n", "import {\n  is,\n  guard,\n  merge,\n  sample,\n  combine,\n  createStore,\n  Unit,\n  Clock,\n  Effect,\n  StoreValue,\n  createEvent,\n  NoInfer,\n  EffectParams,\n  attach,\n} from 'effector';\n\nimport { createRoute } from './create-route';\nimport {\n  RouteInstance,\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n} from '../types';\n\nimport { isRoute } from './is-route';\n\ntype ChainRouteParamsInternalAttach<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: {\n    effect: FX;\n    mapParams: ({\n      params,\n      query,\n    }: {\n      params: Params;\n      query: RouteQuery;\n    }) => NoInfer<EffectParams<FX>>;\n  };\n  openOn?: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsWithEffect<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;\n};\n\ntype ChainRouteParamsAdvanced<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsNormalized<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn: Clock<any>;\n};\n\ntype chainRouteParams<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n> =\n  | RouteInstance<Params>\n  | ChainRouteParamsWithEffect<Params>\n  | ChainRouteParamsAdvanced<Params>\n  | ChainRouteParamsInternalAttach<Params, FX>;\n\nfunction normalizeChainRouteParams<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(params: chainRouteParams<Params, FX>): ChainRouteParamsNormalized<Params> {\n  const resultParams: ChainRouteParamsNormalized<Params> =\n    {} as ChainRouteParamsNormalized<Params>;\n  if (isRoute(params)) {\n    Object.assign(resultParams, {\n      route: params,\n      chainedRoute: createRoute<Params>(),\n      beforeOpen: createEvent(),\n      openOn: merge([params.opened, params.closed]),\n      cancelOn: merge([createEvent()]),\n    });\n    return resultParams;\n  }\n  const effectParams = params as ChainRouteParamsWithEffect<Params>;\n  Object.assign(resultParams, {\n    route: effectParams.route,\n    chainedRoute: effectParams.chainedRoute || createRoute<Params>(),\n    beforeOpen: is.unit(effectParams.beforeOpen)\n      ? effectParams.beforeOpen\n      : attach(effectParams.beforeOpen),\n  });\n  if (is.effect(resultParams.beforeOpen)) {\n    Object.assign(resultParams, {\n      openOn:\n        // @ts-expect-error\n        effectParams.openOn || resultParams.beforeOpen.doneData,\n      cancelOn:\n        // @ts-expect-error\n        effectParams.cancelOn || resultParams.beforeOpen.failData,\n    });\n    return resultParams;\n  }\n  const advancedParams = params as ChainRouteParamsAdvanced<Params>;\n  Object.assign(resultParams, {\n    openOn: sample({ clock: advancedParams.openOn as Unit<any> }),\n    cancelOn: sample({\n      clock: (advancedParams.cancelOn as Unit<any>) || createEvent(),\n    }),\n  });\n  return resultParams;\n}\n\nfunction chainRoute<Params extends RouteParams>(\n  instance: RouteInstance<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsWithEffect<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsAdvanced<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(config: ChainRouteParamsInternalAttach<Params, FX>): RouteInstance<Params>;\n\n/**\n * Creates chained route\n * @link https://github.com/Kelin2025/atomic-router/issues/10\n * @param {RouteInstance<any>} params.route - Route to listen\n * @param {RouteInstance<any>} [params.chainedRoute]  - Route to be created\n * @param {Clock<any>} params.beforeOpen - Will be triggered when `params.route` open\n * @param {Clock<any>} params.openOn - Will open `chainedRoute` if `params.route` is still opened\n * @param {Clock<any>} params.cancelOn - Cancels chain\n * @returns {RouteInstance<any>} `chainedRoute`\n */\nfunction chainRoute<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(params: chainRouteParams<Params, FX>) {\n  const { route, chainedRoute, beforeOpen, openOn, cancelOn } =\n    normalizeChainRouteParams(params);\n  const $params = createStore({} as StoreValue<typeof route['$params']>);\n  const $query = createStore({} as StoreValue<typeof route['$query']>);\n  const $hasSameParams = combine(\n    combine([route.$params, route.$query]),\n    combine([$params, $query]),\n    (current, stored) => {\n      return current[0] === stored[0] && current[1] === stored[1];\n    }\n  );\n  const routeOpened = sample({\n    clock: [route.opened, route.updated],\n  });\n  // 1. Call `beforeOpen` whenever route is opened\n  sample({\n    clock: routeOpened,\n    target: beforeOpen as Unit<RouteParamsAndQuery<any>>,\n  });\n  $params.on(routeOpened, (_prev, { params }) => params);\n  $query.on(routeOpened, (_prev, { query }) => query);\n  // 2. Listen to `openOn` if route is still opened on the same position\n  const chainedRouteResolved = guard({\n    clock: openOn,\n    source: { params: $params, query: $query },\n    filter: $hasSameParams,\n  });\n  sample({\n    clock: chainedRouteResolved,\n    target: chainedRoute.navigate,\n  });\n  // 4. Cancel loading if page closed or `cancelOn` is called\n  // @ts-expect-error\n  const aborted = merge([route.closed, cancelOn]);\n  $params.reset(aborted);\n  $query.reset(aborted);\n  sample({\n    clock: aborted,\n    target: chainedRoute.closed,\n  });\n  return chainedRoute;\n}\n\n// This is written separately to correctly export all type overloads\nexport { chainRoute };\n", "import { Clock, combine, createStore, sample, Store, Unit } from 'effector';\n\nimport { RouteInstance, RouteQuery } from '../types';\nimport { createRouterControls } from './create-router-controls';\n\ntype QueryCleanupStrategy = {\n  irrelevant: boolean;\n  empty: boolean;\n  preserve: string[];\n};\n\ntype QuerySyncParams<T extends Record<string, Store<any>>> = {\n  source: T;\n  clock?: Clock<any>;\n  controls: ReturnType<typeof createRouterControls>;\n  route?: RouteInstance<any>;\n  cleanup?: boolean | Partial<QueryCleanupStrategy>;\n};\n\nexport function querySync<T extends Record<string, Store<any>>>(\n  params: QuerySyncParams<T>\n) {\n  const $isOpened = params.route?.$isOpened ?? createStore(true);\n  const $source = combine(params.source);\n  const clock = (params.clock ?? $source) as Unit<any>;\n  const cleanupStrategy = !('cleanup' in params)\n    ? cleanupStrategies.default\n    : typeof params.cleanup === 'boolean'\n    ? cleanupStrategies[params.cleanup ? 'all' : 'none']\n    : { ...cleanupStrategies.default, ...params.cleanup! };\n\n  const queryUpdatedFromHistory = sample({\n    clock: params.controls.$query,\n    filter: $isOpened,\n  });\n\n  sample({\n    clock,\n    source: combine([$source, params.controls.$query]),\n    filter: $isOpened,\n    fn: ([source, currentQuery]) => {\n      let nextQuery: RouteQuery = {};\n      if (cleanupStrategy.irrelevant) {\n        for (const key of cleanupStrategy.preserve) {\n          if (key in currentQuery) {\n            nextQuery[key] = currentQuery[key];\n          }\n        }\n      } else {\n        nextQuery = { ...currentQuery };\n      }\n      for (const key in source) {\n        nextQuery[key] = source[key];\n      }\n      if (cleanupStrategy.empty) {\n        for (const key in source) {\n          if (!cleanupStrategy.preserve.includes(key) && !nextQuery[key]) {\n            delete nextQuery[key];\n          }\n        }\n      }\n      return nextQuery as RouteQuery;\n    },\n    target: params.controls.$query,\n  });\n\n  for (const k in params.source) {\n    const $queryParam = params.source[k as keyof typeof params.source];\n    $queryParam.on(queryUpdatedFromHistory, (_, query) => {\n      return query[k] ?? $queryParam.defaultState;\n    });\n  }\n}\n\nconst cleanupStrategies = {\n  all: {\n    irrelevant: true,\n    empty: true,\n    preserve: [],\n  },\n  default: {\n    irrelevant: false,\n    empty: true,\n    preserve: [],\n  },\n  none: {\n    irrelevant: false,\n    empty: false,\n    preserve: [],\n  },\n};\n", "import { History } from 'history';\nimport { Effect, Event, Store } from 'effector';\n\nexport type RouteParams = Record<string, any>;\n\nexport type RouteQuery = Record<string, any>;\n\nexport type RouteParamsAndQuery<Params extends RouteParams> = {\n  params: Params;\n  query: RouteQuery;\n};\n\nexport interface NavigateParams<Params extends RouteParams>\n  extends RouteParamsAndQuery<Params> {\n  replace?: boolean;\n}\n\nexport type RouteInstance<Params extends RouteParams> = {\n  $isOpened: Store<boolean>;\n  $params: Store<Params>;\n  $query: Store<RouteQuery>;\n  opened: Event<RouteParamsAndQuery<Params>>;\n  updated: Event<RouteParamsAndQuery<Params>>;\n  closed: Event<void>;\n  navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;\n  open: Effect<\n    Params extends EmptyObject ? void : Params,\n    RouteParamsAndQuery<Params>\n  >;\n  kind: typeof Kind.ROUTE;\n};\n\nexport type RouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  path: string;\n};\n\nexport type UnmappedRouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params> | RouteInstance<Params>[];\n  path: string;\n};\n\nexport type HistoryPushParams = {\n  history: History;\n  path: string;\n  params: RouteParams;\n  query: RouteQuery;\n  method: 'replace' | 'push';\n};\n\nexport type HistoryBackForwardParams = History;\n\nexport type ParamsSerializer = {\n  write: (params: RouteParams) => string;\n  read: (query: string) => RouteParams;\n};\n\n// @ts-expect-error\nexport type PathCreator<Params extends RouteParams> = string;\n\nexport const Kind = {\n  ROUTE: Symbol(),\n};\n\nexport type EmptyObject = { [key in string]: never };\n", "import { createEvent, createStore } from 'effector';\n\nimport { RouteQuery } from '../types';\nimport { paramsEqual } from '../utils/equals';\n\nexport const createRouterControls = () => {\n  return {\n    $query: createStore<RouteQuery>(\n      {},\n      {\n        updateFilter: (update, current) => !paramsEqual(current, update),\n      }\n    ),\n    back: createEvent(),\n    forward: createEvent(),\n  };\n};\n", "import { Kind, RouteInstance } from '../types';\n\n/** Detects whether passed value is a `RouteInstance<any>` or not */\nexport const isRoute = (\n  route: RouteInstance<any> | unknown\n): route is RouteInstance<any> => {\n  return (\n    typeof route === 'object' &&\n    route !== null &&\n    'kind' in route &&\n    // @ts-expect-error\n    route.kind === Kind.ROUTE\n  );\n};\n"],
  "mappings": "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",
  "names": ["i", "j", "value", "_a", "result", "x", "m", "createRoute", "params", "navigateFx", "createEffect", "_ref", "_ref$replace", "replace", "query", "name", "sid", "openFx", "attach", "and", "effect", "mapParams", "or", "$isOpened", "createStore", "$params", "$query", "opened", "createEvent", "updated", "closed", "on", "_", "_ref2", "_ref3", "_ref4", "_ref5", "split", "source", "doneData", "match", "map", "isOpened", "cases", "navigate", "open", "kind", "Kind", "ROUTE", "settings", "derived", "Boolean", "filter", "e", "r", "a", "n", "t", "paramsEqual", "b", "Object", "keys", "length", "k", "buildPath", "_serialize$write", "serialize", "pathname", "compile", "pathCreator", "serializedParams", "write", "URLSearchParams", "matchPath", "actualPath", "matches", "path", "url", "URL", "hash", "join", "assertHistory", "history", "Error", "not", "value", "createHistoryRouter", "base", "routes", "notFoundRoute", "hydrate", "_ref$controls", "controls", "_withFactory", "fn", "createRouterControls", "method", "remappedRoutes", "objects", "basePath", "_step", "next", "_loop", "_next", "routeObj", "Array", "isArray", "route", "push", "_objectSpread", "_iterator", "_createForOfIteratorHelperLoose", "done", "_step2", "derivedRoutes", "nonDerivedRoutes", "_iterator2", "_step3", "_iterator3", "console", "error", "derivedRoute", "setHistory", "navigateFromRouteTriggered", "historyUpdated", "recalculateTriggered", "recalculated", "routesMatched", "routesMismatched", "routeNotFound", "initialized", "$path", "updateFilter", "newQuery", "oldQuery", "$activeRoutes", "$history", "$isFirstCheckPassed", "$isRouteNavigateInProgress", "pushFx", "historyPushFx", "subscribeHistoryFx", "scopedHistoryUpdated", "scopeBind", "err", "listen", "historyUpdatedParsed", "sample", "clock", "_serialize$read", "location", "read", "search", "fromEntries", "historyUpdateTriggered", "target", "_serialize$read2", "currentRouteMatched", "filterMap", "containsCurrentRoute", "currentRouteMismatched", "routeStateChangeRequested", "_ref16", "paramsAndQuery", "_ref17", "reset", "matchingRoutes", "mismatchingRoutes", "includes", "_matchPath", "forEach", "mismatchedRoute", "mismatchedIndex", "some", "matchedRoute", "splice", "matching", "mismatching", "_ref6", "matchingRecalculated", "_ref7", "_ref8", "_ref9", "recheckResult", "isRoute", "_ref10", "_ref11", "back", "historyBackFx", "forward", "historyForwardFx", "controlsQuery", "localQuery", "_ref12", "_ref13", "isNavigateInProgress", "realHistory", "_serialize$read3", "_realHistory$location", "_realHistory$location2", "realQuery", "_ref15", "qs", "activeRoutes", "isFirstCheckPassed", "redirect", "options", "toStore", "payload", "is", "store", "chainRoute", "normalizeChainRouteParams", "resultParams", "assign", "chainedRoute", "beforeOpen", "openOn", "merge", "cancelOn", "effectParams", "unit", "failData", "advancedParams", "$hasSameParams", "combine", "current", "stored", "routeOpened", "_prev", "chainedRouteResolved", "guard", "aborted", "querySync", "_params$route$$isOpen", "_params$route", "_params$clock", "$source", "cleanupStrategy", "cleanup", "cleanupStrategies", "queryUpdatedFromHistory", "currentQuery", "nextQuery", "irrelevant", "preserve", "key", "empty", "$queryParam", "_query$k", "defaultState", "Symbol", "update", "recheckResults", "recheck", "find", "all", "default", "none"]
}
