// node_modules/effector/effector.mjs
function e(e2, t2) {
  for (let r2 in e2)
    t2(e2[r2], r2);
}
function t(e2, t2) {
  e2.forEach(t2);
}
function r(e2, t2) {
  if (!e2)
    throw Error(t2);
}
function a(e2, t2) {
  let r2 = L(e2).meta || {};
  he = { id: L(e2).id, parent: he, value: e2, template: r2.template || ve(), sidRoot: r2.sidRoot || he && he.sidRoot, meta: r2 };
  try {
    return t2();
  } finally {
    ye("region"), he = V(he);
  }
}
function n({ node: e2 = [], from: r2, source: a2, parent: n2 = r2 || a2, to: i2, target: o2, child: l2 = i2 || o2, scope: s2 = {}, meta: f2 = {}, family: d2 = { type: "regular" }, regional: u2 } = {}) {
  let c2 = Se(n2), p2 = Se(d2.links), m2 = Se(d2.owners), g2 = [];
  t(e2, (e3) => e3 && le(g2, e3));
  let h2 = { id: pe(), seq: g2, next: Se(l2), meta: f2, scope: s2, family: { type: d2.type || "crosslink", links: p2, owners: m2 } };
  return t(p2, (e3) => le(T(e3), h2)), t(m2, (e3) => le(B(e3), h2)), t(c2, (e3) => le(e3.next, h2)), u2 && he && we(H(he), [h2]), h2;
}
function i(e2, r2, a2) {
  let n2, i2 = nt, o2 = null, l2 = et;
  if (e2.target && (r2 = e2.params, a2 = e2.defer, n2 = e2.meta, i2 = "page" in e2 ? e2.page : i2, e2.stack && (o2 = e2.stack), l2 = G(e2) || l2, e2 = e2.target), l2 && et && l2 !== et && (et = null), Array.isArray(e2))
    for (let t2 = 0; t2 < e2.length; t2++)
      Qe("pure", i2, L(e2[t2]), o2, r2[t2], l2, n2);
  else
    Qe("pure", i2, L(e2), o2, r2, l2, n2);
  if (a2 && !tt)
    return;
  let s2, f2, d2, u2, c2, p2, m2 = { isRoot: tt, currentPage: nt, scope: et, isWatch: rt, isPure: at };
  tt = 0;
  e:
    for (; u2 = Ke(); ) {
      let { idx: e3, stack: r3, type: a3 } = u2;
      d2 = r3.node, nt = c2 = r3.page, et = G(r3), c2 ? p2 = c2.reg : et && (p2 = et.reg);
      let n3 = !!c2, i3 = !!et, o3 = { fail: 0, scope: d2.scope };
      s2 = f2 = 0;
      for (let t2 = e3; t2 < d2.seq.length && !s2; t2++) {
        let l3 = d2.seq[t2];
        if (l3.order) {
          let { priority: n4, barrierID: i4 } = l3.order, o4 = i4 ? c2 ? `${c2.fullID}_${i4}` : i4 : 0;
          if (t2 !== e3 || a3 !== n4) {
            i4 ? Ze.has(o4) || (Ze.add(o4), Xe(t2, r3, n4, i4)) : Xe(t2, r3, n4);
            continue e;
          }
          i4 && Ze.delete(o4);
        }
        switch (l3.type) {
          case "mov": {
            let e5, t3 = l3.data;
            switch (t3.from) {
              case P:
                e5 = H(r3);
                break;
              case "a":
              case "b":
                e5 = r3[t3.from];
                break;
              case "value":
                e5 = t3.store;
                break;
              case "store":
                if (p2 && !p2[t3.store.id])
                  if (n3) {
                    let e6 = st(c2, t3.store.id);
                    r3.page = c2 = e6, e6 ? p2 = e6.reg : i3 ? (pt(et, t3.store, 0, 1, t3.softRead), p2 = et.reg) : p2 = void 0;
                  } else
                    i3 && pt(et, t3.store, 0, 1, t3.softRead);
                e5 = We(p2 && p2[t3.store.id] || t3.store);
            }
            switch (t3.to) {
              case P:
                r3.value = e5;
                break;
              case "a":
              case "b":
                r3[t3.to] = e5;
                break;
              case "store":
                dt(c2, et, d2, t3.target).current = e5;
            }
            break;
          }
          case "compute":
            let e4 = l3.data;
            if (e4.fn) {
              rt = "watch" === J(d2, "op"), at = e4.pure;
              let t3 = e4.safe ? (0, e4.fn)(H(r3), o3.scope, r3) : mt(o3, e4.fn, r3);
              e4.filter ? f2 = !t3 : r3.value = t3, rt = m2.isWatch, at = m2.isPure;
            }
        }
        s2 = o3.fail || f2;
      }
      if (ft && ft(r3, o3), !s2) {
        let e4 = H(r3), a4 = G(r3);
        if (t(d2.next, (t2) => {
          Qe("child", c2, t2, r3, e4, a4);
        }), a4) {
          J(d2, "needFxCounter") && Qe("child", c2, a4.fxCount, r3, e4, a4), J(d2, "storeChange") && Qe("child", c2, a4.storeChange, r3, e4, a4), J(d2, "warnSerialize") && Qe("child", c2, a4.warnSerializeNode, r3, e4, a4);
          let n4 = a4.additionalLinks[d2.id];
          n4 && t(n4, (t2) => {
            Qe("child", c2, t2, r3, e4, a4);
          });
        }
      }
    }
  tt = m2.isRoot, nt = m2.currentPage, et = G(m2);
}
function o(t2, r2 = "combine") {
  let a2 = r2 + "(", n2 = "", i2 = 0;
  return e(t2, (e2) => {
    i2 < 25 && (null != e2 && (a2 += n2, a2 += X(e2) ? Q(e2).fullName : e2.toString()), i2 += 1, n2 = ", ");
  }), a2 + ")";
}
function l(e2, t2) {
  e2.shortName = t2, Object.assign(Q(e2), s(t2, V(e2)));
}
function s(e2, t2) {
  let r2, a2, n2 = e2;
  if (t2) {
    let n3 = Q(t2);
    0 === e2.length ? (r2 = n3.path, a2 = n3.fullName) : (r2 = n3.path.concat([e2]), a2 = 0 === n3.fullName.length ? e2 : n3.fullName + "/" + e2);
  } else
    r2 = 0 === e2.length ? [] : [e2], a2 = e2;
  return { shortName: n2, fullName: a2, path: r2 };
}
function f(e2, t2) {
  let r2 = t2 ? e2 : e2[0];
  ze(r2);
  let a2 = r2.or, n2 = r2.and;
  if (n2) {
    let r3 = t2 ? n2 : n2[0];
    if (Me(r3) && "and" in r3) {
      let r4 = f(n2, t2);
      e2 = r4[0], a2 = { ...a2, ...r4[1] };
    } else
      e2 = n2;
  }
  return [e2, a2];
}
function d(e2, ...t2) {
  let r2 = ve();
  if (r2) {
    let a2 = r2.handlers[e2];
    if (a2)
      return a2(r2, ...t2);
  }
}
function u(e2, t2) {
  let r2 = gt({ or: t2, and: "string" == typeof e2 ? { name: e2 } : e2 }), a2 = (e3, ...t3) => (se(!J(a2, "derived"), "call of derived event", "createEvent"), se(!at, "unit call from pure function", "operators like sample"), nt ? ((e4, t4, r3, a3) => {
    let n2 = nt, i2 = null;
    if (t4)
      for (i2 = nt; i2 && i2.template !== t4; )
        i2 = V(i2);
    lt(i2);
    let o3 = e4.create(r3, a3);
    return lt(n2), o3;
  })(a2, o2, e3, t3) : a2.create(e3, t3)), o2 = ve(), l2 = Object.assign(a2, { graphite: n({ meta: $t(r2.actualOp || "event", a2, r2), regional: 1 }), create: (e3) => (i({ target: a2, params: e3, scope: et }), e3), watch: (e3) => Mt(a2, e3), map: (e3) => zt(a2, _, e3, [Le()]), filter: (e3) => zt(a2, "filter", e3.fn ? e3 : e3.fn, [Le(qe, 1)]), filterMap: (e3) => zt(a2, "filterMap", e3, [Le(), _e((e4) => !$e(e4), 1)]), prepend(e3) {
    let t3 = u("* → " + a2.shortName, { parent: V(a2) });
    return d("eventPrepend", L(t3)), wt(t3, a2, [Le()], "prepend", e3), xt(a2, t3), t3;
  } });
  return null != r2 && r2.domain && r2.domain.hooks.event(l2), K(l2, "id", l2.graphite.id), ye(l2.graphite), l2;
}
function c(e2, a2, n2, i2) {
  return Ce(n2, a2, "first argument"), r(xe(i2), "second argument should be a function"), se(!J(e2, "derived"), `${a2} in derived store`, `${a2} in store created via createStore`), t(Array.isArray(n2) ? n2 : [n2], (t2) => {
    e2.off(t2), U(e2).set(t2, kt(jt(t2, e2, "on", Oe, i2)));
  }), e2;
}
function p(e2, a2) {
  let o2 = gt(a2), l2 = Be(e2), s2 = u({ named: "updates", derived: 1 });
  d("storeBase", l2);
  let f2 = l2.id, m2 = { subscribers: /* @__PURE__ */ new Map(), updates: s2, defaultState: e2, stateRef: l2, getState() {
    let e3, t2 = l2;
    if (nt) {
      let t3 = nt;
      for (; t3 && !t3.reg[f2]; )
        t3 = V(t3);
      t3 && (e3 = t3);
    }
    return !e3 && et && (pt(et, l2, 1), e3 = et), e3 && (t2 = e3.reg[f2]), We(t2);
  }, setState: (e3) => i({ target: m2, params: e3, defer: 1, scope: et }), reset: (...e3) => (t(e3, (e4) => c(m2, ".reset", e4, () => m2.defaultState)), m2), on: (e3, t2) => c(m2, ".on", e3, t2), off(e3) {
    let t2 = U(m2).get(e3);
    return t2 && (t2(), U(m2).delete(e3)), m2;
  }, map(e3, t2) {
    let r2, a3;
    Me(e3) && (r2 = e3, e3 = e3.fn), se($e(t2), "second argument of store.map", "updateFilter");
    let n2 = m2.getState();
    ve() ? a3 = null : $e(n2) || (a3 = e3(n2, t2));
    let i2 = p(a3, { name: `${m2.shortName} → *`, derived: 1, and: r2 }), o3 = jt(m2, i2, _, Ie, e3);
    return He(W(i2), { type: _, fn: e3, from: l2 }), W(i2).noInit = 1, d("storeMap", l2, o3), i2;
  }, watch(e3, t2) {
    if (!t2 || !X(e3)) {
      let t3 = Mt(m2, e3);
      return d("storeWatch", l2, e3) || e3(m2.getState()), t3;
    }
    return r(xe(t2), "second argument should be a function"), e3.watch((e4) => t2(m2.getState(), e4));
  } }, g2 = $t("store", m2, o2), h2 = m2.defaultConfig.updateFilter;
  m2.graphite = n({ scope: { state: l2, fn: h2 }, node: [_e((e3, t2, r2) => (r2.scope && !r2.scope.reg[l2.id] && (r2.b = 1), e3)), Pe(l2), _e((e3, t2, { a: r2, b: a3 }) => !$e(e3) && (e3 !== r2 || a3), 1), h2 && Le(Ie, 1), Re({ from: P, target: l2 })], child: s2, meta: { ...g2, defaultState: e2 }, regional: 1 }), K(m2, "id", m2.graphite.id), K(m2, "rootStateRefId", f2);
  let y2 = J(m2, "serialize"), v2 = J(m2, "derived"), b2 = "ignore" === y2, k2 = J(m2, "sid");
  return k2 && (K(m2, "storeChange", 1), l2.sid = k2), k2 || b2 || v2 || K(m2, "warnSerialize", 1), r(v2 || !$e(e2), "current state can't be undefined, use null instead"), we(m2, [s2]), null != o2 && o2.domain && o2.domain.hooks.store(m2), v2 || (m2.reinit = u({ named: "reinit" }), m2.reset(m2.reinit)), l2.meta = m2.graphite.meta, ye(m2.graphite), m2;
}
function m(...e2) {
  let t2, a2, n2;
  [e2, n2] = f(e2);
  let i2, o2, l2, s2 = e2[e2.length - 1];
  if (xe(s2) ? (a2 = e2.slice(0, -1), t2 = s2) : a2 = e2, 1 === a2.length) {
    let e3 = a2[0];
    Z(e3) || (i2 = e3, o2 = 1);
  }
  if (!o2 && (i2 = a2, t2)) {
    l2 = 1;
    let e3 = t2;
    t2 = (t3) => e3(...t3);
  }
  return r(Me(i2), "shape should be an object"), Ct(Array.isArray(i2), !l2, i2, n2, t2);
}
function g(...e2) {
  return se(0, "createStoreObject", "combine"), m(...e2);
}
function h() {
  let e2 = {};
  return e2.req = new Promise((t2, r2) => {
    e2.rs = t2, e2.rj = r2;
  }), e2.req.catch(() => {
  }), e2;
}
function y(e2, t2 = {}) {
  let a2 = gt(xe(e2) ? { handler: e2 } : e2, t2), o2 = u(xe(e2) ? { handler: e2 } : e2, { ...t2, actualOp: "effect" }), l2 = L(o2);
  K(l2, "op", o2.kind = "effect"), o2.use = (e3) => (r(xe(e3), ".use argument should be a function"), g2.scope.handler = e3, o2), o2.use.getCurrent = () => g2.scope.handler;
  let s2 = o2.finally = u({ named: "finally", derived: 1 }), f2 = o2.done = s2.filterMap({ named: "done", fn({ status: e3, params: t3, result: r2 }) {
    if ("done" === e3)
      return { params: t3, result: r2 };
  } }), d2 = o2.fail = s2.filterMap({ named: "fail", fn({ status: e3, params: t3, error: r2 }) {
    if ("fail" === e3)
      return { params: t3, error: r2 };
  } }), c2 = o2.doneData = f2.map({ named: "doneData", fn: ({ result: e3 }) => e3 }), m2 = o2.failData = d2.map({ named: "failData", fn: ({ error: e3 }) => e3 }), g2 = n({ scope: { handler: o2.defaultConfig.handler || (() => r(0, `no handler used in ${o2.getType()}`)) }, node: [_e((e3, t3, r2) => {
    let a3 = t3.handler, n2 = G(r2);
    if (n2) {
      let e4 = o2.sid ? n2.handlers.sidMap[o2.sid] : n2.handlers.unitMap.get(o2);
      e4 && (a3 = e4);
    }
    return e3.handler = a3, e3;
  }, 0, 1), _e(({ params: e3, req: t3, handler: r2, args: a3 = [e3] }, n2, i2) => {
    let o3 = It(i2), l3 = Ot(e3, t3, 1, s2, i2, o3), f3 = Ot(e3, t3, 0, s2, i2, o3), [d3, u2] = At(r2, f3, a3);
    d3 && (Me(u2) && xe(u2.then) ? u2.then(l3, f3) : l3(u2));
  }, 0, 1)], meta: { op: "fx", fx: "runner" } });
  l2.scope.runner = g2, le(l2.seq, _e((e3, { runner: t3 }, r2) => {
    let a3 = V(r2) ? { params: e3, req: { rs(e4) {
    }, rj(e4) {
    } } } : e3;
    return r2.meta || (r2.meta = { fxID: me() }), i({ target: t3, params: a3, defer: 1, scope: G(r2), meta: r2.meta }), a3.params;
  }, 0, 1)), o2.create = (e3) => {
    let t3 = h(), r2 = { params: e3, req: t3 };
    if (et && !rt) {
      let e4 = et;
      t3.req.finally(() => {
        ot(e4);
      }).catch(() => {
      });
    }
    return i({ target: o2, params: r2, scope: et }), t3.req;
  };
  let y2 = o2.inFlight = p(0, { serialize: "ignore", named: (J(o2, "name") || o2.graphite.id) + ".inFlight" }).on(o2, (e3) => e3 + 1).on(s2, (e3) => e3 - 1).map({ fn: (e3) => e3, named: "inFlight" });
  K(s2, "needFxCounter", "dec"), K(o2, "needFxCounter", 1);
  let v2 = o2.pending = y2.map({ fn: (e3) => e3 > 0, named: "pending" });
  return we(o2, [s2, f2, d2, c2, m2, v2, y2]), null != a2 && a2.domain && a2.domain.hooks.effect(o2), o2;
}
function v(e2) {
  let t2;
  [e2, t2] = f(e2, 1);
  let { source: r2, effect: a2, mapParams: n2 } = e2, o2 = y(e2, t2);
  K(o2, "attached", 1);
  let l2, { runner: d2 } = L(o2).scope, u2 = _e((e3, t3, a3) => {
    let l3, { params: s2, req: f2, handler: d3 } = e3, u3 = o2.finally, c3 = It(a3), p2 = Ot(s2, f2, 0, u3, a3, c3), m2 = a3.a, g2 = te(d3), h2 = 1;
    if (n2 ? [h2, l3] = At(n2, p2, [s2, m2]) : l3 = r2 && g2 ? m2 : s2, h2) {
      if (!g2)
        return e3.args = [m2, l3], 1;
      i({ target: d3, params: { params: l3, req: { rs: Ot(s2, f2, 1, u3, a3, c3), rj: p2 } }, page: a3.page, defer: 1, meta: a3.meta });
    }
  }, 1, 1);
  if (r2) {
    let e3;
    Z(r2) ? (e3 = r2, we(e3, [o2])) : (e3 = m(r2), we(o2, [e3])), l2 = [Pe(W(e3)), u2];
  } else
    l2 = [u2];
  d2.seq.splice(1, 0, ...l2), o2.use(a2);
  let c2 = V(a2);
  return c2 && (Object.assign(Q(o2), s(o2.shortName, c2)), o2.defaultConfig.parent = c2), xt(a2, o2, "effect"), o2;
}
function b(...t2) {
  let [[r2, a2], n2] = f(t2), i2 = {};
  return e(a2, (e2, t3) => {
    let a3 = i2[t3] = u(t3, { parent: V(r2), config: n2 });
    r2.on(a3, e2), xt(r2, a3);
  }), i2;
}
function k(r2, a2) {
  let o2 = gt({ or: a2, and: "string" == typeof r2 ? { name: r2 } : r2 }), l2 = n({ family: { type: "domain" }, regional: 1, parent: (null == o2 ? void 0 : o2.domain) || (null == o2 ? void 0 : o2.parent) }), s2 = { history: {}, graphite: l2, hooks: {} };
  l2.meta = $t("domain", s2, { parent: (null == o2 ? void 0 : o2.domain) || (null == o2 ? void 0 : o2.parent), or: o2 }), e({ Event: u, Effect: y, Store: p, Domain: k }, (e2, r3) => {
    let a3 = r3.toLowerCase(), n2 = u({ named: `on${r3}` });
    s2.hooks[a3] = n2;
    let o3 = /* @__PURE__ */ new Set();
    s2.history[`${a3}s`] = o3, n2.create = (e3) => (i(n2, e3), e3), le(L(n2).seq, _e((e3, t2, r4) => (r4.scope = null, e3))), n2.watch((e3) => {
      we(s2, [e3]), o3.add(e3), e3.ownerSet || (e3.ownerSet = o3), V(e3) || (e3.parent = s2);
    }), we(s2, [n2]), s2[`onCreate${r3}`] = (e3) => (t(o3, e3), n2.watch(e3)), s2[`create${r3}`] = s2[a3] = (t2, r4) => {
      let a4 = gt({ and: r4, or: t2 });
      return null != a4 && a4.domain ? e2(t2, r4) : n2(e2(t2, { parent: s2, or: a4 }));
    };
  });
  let f2 = V(s2);
  return f2 && e(s2.hooks, (e2, t2) => wt(e2, f2.hooks[t2])), null != o2 && o2.domain && o2.domain.hooks.domain(s2), s2;
}
function w(e2) {
  ze(e2);
  let t2 = E in e2 ? e2[E]() : e2;
  r(t2.subscribe, "expect observable to have .subscribe");
  let a2 = u(), n2 = kt(a2);
  return t2.subscribe({ next: a2, error: n2, complete: n2 }), a2;
}
function S(e2, t2) {
  Ce(e2, "merge", "first argument");
  let r2 = u({ name: o(e2, "merge"), derived: 1, and: t2 });
  return wt(e2, r2, [], "merge"), r2;
}
function M(e2, a2) {
  let n2 = 0;
  return t(Nt, (t2) => {
    t2 in e2 && (r(null != e2[t2], Ft(a2, t2)), n2 = 1);
  }), n2;
}
function x(...e2) {
  let t2, r2, a2, n2, [[i2, o2, l2], s2] = f(e2), d2 = 1;
  return $e(o2) && Me(i2) && M(i2, "sample") && (o2 = i2.clock, l2 = i2.fn, d2 = !i2.greedy, n2 = i2.filter, t2 = i2.target, r2 = i2.name, a2 = i2.sid, i2 = i2.source), Rt("sample", o2, i2, n2, t2, l2, r2, s2, d2, 1, 0, a2);
}
function $(...e2) {
  let [[t2, r2], a2] = f(e2);
  return r2 || (r2 = t2, t2 = r2.source), M(r2, "guard"), Rt("guard", r2.clock, t2, r2.filter, r2.target, null, r2.name, a2, !r2.greedy, 0, 1);
}
function z(t2, r2, a2) {
  if (Z(t2))
    return se(0, "restore($store)"), t2;
  if (ee(t2) || te(t2)) {
    let e2 = V(t2), n3 = p(r2, { parent: e2, name: t2.shortName, and: a2 });
    return wt(te(t2) ? t2.doneData : t2, n3), e2 && e2.hooks.store(n3), n3;
  }
  let n2 = Array.isArray(t2) ? [] : {};
  return e(t2, (e2, t3) => n2[t3] = Z(e2) ? e2 : p(e2, { name: t3 })), n2;
}
function j(...t2) {
  let a2, i2, o2 = "split", [[l2, s2], c2] = f(t2), p2 = !s2;
  p2 && (a2 = l2.cases, s2 = l2.match, i2 = l2.clock, l2 = l2.source);
  let m2 = Z(s2), g2 = !X(s2) && xe(s2), h2 = !m2 && !g2 && Me(s2);
  r(X(l2), "source must be a unit"), a2 || (a2 = {}), p2 ? e(a2, (e2, t3) => Ae(o2, e2, `cases.${t3}`)) : (r(h2, "match should be an object"), e(s2, (e2, t3) => a2[t3] = u({ derived: 1, named: `cases.${t3}`, and: c2 })), a2.__ = u({ derived: 1, named: "cases.__", and: c2 }));
  let y2, v2 = new Set([].concat(l2, i2 || [], Object.values(a2))), b2 = Object.keys(m2 || g2 ? a2 : s2);
  if (m2 || g2)
    m2 && v2.add(s2), y2 = [m2 && Pe(W(s2), 0, 1), De({ safe: m2, filter: 1, pure: !m2, fn(e2, t3, r2) {
      let a3 = String(m2 ? r2.a : s2(e2));
      _t(t3, ie(b2, a3) ? a3 : "__", e2, r2);
    } })];
  else if (h2) {
    let t3 = Be({});
    t3.type = "shape";
    let r2, a3 = [];
    e(s2, (e2, n2) => {
      if (X(e2)) {
        r2 = 1, le(a3, n2), v2.add(e2);
        let i3 = wt(e2, [], [Pe(t3), _e((e3, t4, { a: r3 }) => r3[n2] = e3)]);
        if (Z(e2)) {
          t3.current[n2] = e2.getState();
          let r3 = W(e2);
          He(t3, { from: r3, field: n2, type: "field" }), d("splitMatchStore", r3, i3);
        }
      }
    }), r2 && d("splitBase", t3), y2 = [r2 && Pe(t3, 0, 1), Le((e2, t4, r3) => {
      for (let n2 = 0; n2 < b2.length; n2++) {
        let i3 = b2[n2];
        if (ie(a3, i3) ? r3.a[i3] : s2[i3](e2))
          return void _t(t4, i3, e2, r3);
      }
      _t(t4, "__", e2, r3);
    }, 1)];
  } else
    r(0, "expect match to be unit, function or object");
  let k2 = n({ meta: { op: o2 }, parent: i2 ? [] : l2, scope: a2, node: y2, family: { owners: Array.from(v2) }, regional: 1 });
  if (i2 && Rt(o2, i2, l2, null, k2, null, o2, c2, 0, 0, 0), !p2)
    return a2;
}
function C(e2, { scope: t2, params: r2 } = {}) {
  if (!X(e2))
    return Promise.reject(new Error("first argument should be unit"));
  if (!(te(e2) || ee(e2) || Z(e2) || ae(e2)))
    return Promise.reject(new Error("first argument accepts only effects, events, stores or scopes"));
  ae(e2) && (t2 = e2);
  let a2 = h();
  a2.parentFork = et;
  let { fxCount: n2 } = t2;
  le(n2.scope.defers, a2);
  let o2 = [], l2 = [];
  return ae(e2) || (le(o2, e2), le(l2, te(e2) ? { params: r2, req: { rs(e3) {
    a2.value = { status: "done", value: e3 };
  }, rj(e3) {
    a2.value = { status: "fail", value: e3 };
  } } } : r2)), le(o2, n2), le(l2, null), i({ target: o2, params: l2, scope: t2 }), a2.req;
}
function A(e2, r2, a2) {
  let n2 = [];
  (function e3(i2) {
    ie(n2, i2) || (le(n2, i2), "store" === J(i2, "op") && (a2 || J(i2, "sid")) && r2(i2, J(i2, "sid")), t(i2.next, e3), t(T(i2), e3), t(B(i2), e3));
  })(e2);
}
function I(e2, a2) {
  let n2 = Array.isArray(e2) ? new Map(e2) : e2, i2 = /* @__PURE__ */ new Map();
  if (n2 instanceof Map) {
    let e3 = {};
    return t(n2, (t2, n3) => {
      r(X(n3), "Map key should be a unit"), a2 && a2(n3, t2), n3.sid ? (r(!(n3.sid in e3), "duplicate sid found"), e3[n3.sid] = t2) : i2.set(n3, t2);
    }), { sidMap: e3, unitMap: i2 };
  }
  return { sidMap: n2, unitMap: i2 };
}
function O(e2, a2) {
  let i2, o2 = e2;
  re(e2) && (i2 = e2, o2 = a2);
  let l2 = ((e3) => {
    let r2 = n({ scope: { defers: [], inFlight: 0, fxID: 0 }, node: [_e((e4, t2, r3) => {
      V(r3) ? "dec" === J(V(r3).node, "needFxCounter") ? t2.inFlight -= 1 : (t2.inFlight += 1, t2.fxID += 1) : t2.fxID += 1;
    }), De({ priority: "sampler", batch: 1 }), _e((e4, r3) => {
      let { defers: a4, fxID: n2 } = r3;
      r3.inFlight > 0 || 0 === a4.length || Promise.resolve().then(() => {
        r3.fxID === n2 && t(a4.splice(0, a4.length), (e5) => {
          ot(e5.parentFork), e5.rs(e5.value);
        });
      });
    }, 0, 1)] }), a3 = n({ node: [_e((e4, t2, r3) => {
      let a4 = V(r3);
      if (a4) {
        let t3 = a4.node;
        if (!J(t3, "isCombine") || V(a4) && "combine" !== J(V(a4).node, "op")) {
          let a5 = G(r3), n2 = t3.scope.state.id, i4 = J(t3, "sid");
          a5.sidIdMap[i4] = n2, a5.values.sidMap[i4] = e4;
          let o4 = J(t3, "serialize");
          o4 && a5.sidSerializeSettings.set(i4, "ignore" === o4 ? { ignore: 1 } : { ignore: 0, write: o4.write });
        }
      }
    })] }), i3 = n({ node: [_e((e4, t2, r3) => {
      let a4 = G(r3);
      if (a4) {
        let e5 = V(r3);
        e5 && (!J(e5.node, "isCombine") || V(e5) && "combine" !== J(V(e5).node, "op")) && (a4.warnSerialize = 1);
      }
    })] }), o3 = { cloneOf: e3, reg: {}, values: { sidMap: {}, idMap: {} }, sidIdMap: {}, sidSerializeSettings: /* @__PURE__ */ new Map(), getState(e4) {
      if ("current" in e4)
        return dt(nt, o3, null, e4).current;
      let t2 = L(e4);
      return dt(nt, o3, t2, t2.scope.state, 1).current;
    }, kind: "scope", graphite: n({ family: { type: "domain", links: [r2, a3, i3] }, meta: { unit: "fork" }, scope: { forkInFlightCounter: r2 } }), additionalLinks: {}, handlers: { sidMap: {}, unitMap: /* @__PURE__ */ new Map() }, fxCount: r2, storeChange: a3, warnSerializeNode: i3, activeEffects: [] };
    return o3;
  })(i2);
  if (o2) {
    let e3 = o2.scope;
    if (e3) {
      let r2 = e3.activeEffects;
      e3.activeEffects = [], l2.activeEffects = r2, t(r2, (e4) => e4.ref = l2);
    }
    if (o2.values) {
      let { sidMap: e4, unitMap: a3 } = I(o2.values, (e5) => r(Z(e5), "Values map can contain only stores as keys"));
      Object.assign(l2.values.sidMap, e4), t(a3, (e5, t2) => {
        l2.values.idMap[t2.stateRef.id] = e5;
      }), l2.fromSerialize = !(Array.isArray(o2.values) || o2.values instanceof Map);
    }
    o2.handlers && (l2.handlers = I(o2.handlers, (e4) => r(te(e4), "Handlers map can contain only effects as keys")));
  }
  return l2;
}
function q(e2, { values: a2 }) {
  r(Me(a2), "values property should be an object");
  let { sidMap: n2, unitMap: o2 } = I(a2), l2 = Object.getOwnPropertyNames(n2), s2 = {};
  t(o2, (e3, t2) => {
    s2[t2.stateRef.id] = t2;
  });
  let f2, d2, u2, c2 = [], p2 = [];
  ae(e2) ? (f2 = e2, u2 = 1, r(f2.cloneOf, "scope should be created from domain"), d2 = L(f2.cloneOf)) : re(e2) ? d2 = L(e2) : r(0, "first argument of hydrate should be domain or scope"), A(d2, (e3, t2) => {
    if (t2 && ie(l2, t2)) {
      le(c2, e3);
      let r2 = J(e3, "serialize");
      r2 && "ignore" !== r2 && (n2[t2] = r2.read(n2[t2])), le(p2, n2[t2]);
    } else
      e3.scope.state.id in s2 && (le(c2, e3), le(p2, o2.get(s2[e3.scope.state.id])));
  }, 1), i({ target: c2, params: p2, scope: f2 }), u2 && Object.assign(f2.values.sidMap, n2);
}
function N(e2, { scope: t2, safe: a2 } = {}) {
  r(t2 || et || a2, "scopeBind cannot be called outside of forked .watch");
  let n2 = t2 || et;
  return te(e2) ? (t3) => {
    let r2 = h();
    return i({ target: e2, params: { params: t3, req: r2 }, scope: n2 }), r2.req;
  } : (t3) => (i({ target: e2, params: t3, scope: n2 }), t3);
}
function F(t2, a2 = {}) {
  t2.warnSerialize && console.error("There is a store without sid in this scope, its value is omitted");
  let n2 = a2.ignore ? a2.ignore.map(({ sid: e2 }) => e2) : [], i2 = {};
  return e(t2.values.sidMap, (e2, r2) => {
    var a3;
    if (ie(n2, r2))
      return;
    let o2 = t2.sidIdMap[r2], l2 = null !== (a3 = t2.sidSerializeSettings.get(r2)) && void 0 !== a3 ? a3 : { ignore: 0, write: Lt };
    l2.ignore || (i2[r2] = (0, l2.write)(o2 && o2 in t2.reg ? t2.reg[o2].current : e2));
  }), "onlyChanges" in a2 && !a2.onlyChanges && (r(t2.cloneOf, "scope should be created from domain"), A(L(t2.cloneOf), (e2, r2) => {
    r2 in i2 || ie(n2, r2) || J(e2, "isCombine") || "ignore" === J(e2, "serialize") || (i2[r2] = t2.getState(e2));
  })), i2;
}
function R({ unit: e2, fn: t2, scope: r2 }) {
  let a2 = [Te.run({ fn: (e3) => t2(e3) })];
  if (r2) {
    let t3 = n({ node: a2 }), i2 = e2.graphite.id, o2 = r2.additionalLinks, l2 = o2[i2] || [];
    return o2[i2] = l2, l2.push(t3), D(() => {
      let e3 = l2.indexOf(t3);
      -1 !== e3 && l2.splice(e3, 1), bt(t3);
    });
  }
  {
    let t3 = n({ node: a2, parent: [e2], family: { owners: e2 } });
    return D(() => {
      bt(t3);
    });
  }
}
function D(e2) {
  let t2 = () => e2();
  return t2.unsubscribe = () => e2(), t2;
}
var E = "undefined" != typeof Symbol && Symbol.observable || "@@observable";
var _ = "map";
var P = "stack";
var L = (e2) => e2.graphite || e2;
var T = (e2) => e2.family.owners;
var B = (e2) => e2.family.links;
var W = (e2) => e2.stateRef;
var H = (e2) => e2.value;
var U = (e2) => e2.subscribers;
var V = (e2) => e2.parent;
var G = (e2) => e2.scope;
var J = (e2, t2) => L(e2).meta[t2];
var K = (e2, t2, r2) => L(e2).meta[t2] = r2;
var Q = (e2) => e2.compositeName;
var X = (e2) => (xe(e2) || Me(e2)) && "kind" in e2;
var Y = (e2) => (t2) => X(t2) && t2.kind === e2;
var Z = Y("store");
var ee = Y("event");
var te = Y("effect");
var re = Y("domain");
var ae = Y("scope");
var ne = { __proto__: null, unit: X, store: Z, event: ee, effect: te, domain: re, scope: ae, attached: (e2) => te(e2) && 1 == J(e2, "attached") };
var ie = (e2, t2) => e2.includes(t2);
var oe = (e2, t2) => {
  let r2 = e2.indexOf(t2);
  -1 !== r2 && e2.splice(r2, 1);
};
var le = (e2, t2) => e2.push(t2);
var se = (e2, t2, r2) => !e2 && console.error(`${t2} is deprecated${r2 ? `, use ${r2} instead` : ""}`);
var fe = () => {
  let e2 = 0;
  return () => "" + ++e2;
};
var de;
var ue = fe();
var ce = fe();
var pe = fe();
var me = fe();
var ge = (e2) => {
  de = e2;
};
var he = null;
var ye = (e2) => {
  de && de(e2, he);
};
var ve = () => he && he.template;
var be = (e2) => (e2 && he && he.sidRoot && (e2 = `${he.sidRoot}|${e2}`), e2);
var ke = ({ sid: e2, name: t2, loc: r2, method: i2, fn: o2 }) => a(n({ meta: { sidRoot: be(e2), sid: e2, name: t2, loc: r2, method: i2, type: "factory" } }), o2);
var we = (e2, r2) => {
  let a2 = L(e2);
  t(r2, (e3) => {
    let t2 = L(e3);
    "domain" !== a2.family.type && (t2.family.type = "crosslink"), le(T(t2), a2), le(B(a2), t2);
  });
};
var Se = (e2 = []) => (Array.isArray(e2) ? e2 : [e2]).flat().map(L);
var Me = (e2) => "object" == typeof e2 && null !== e2;
var xe = (e2) => "function" == typeof e2;
var $e = (e2) => void 0 === e2;
var ze = (e2) => r(Me(e2) || xe(e2), "expect first argument be an object");
var je = (e2, t2, a2, n2) => r(!(!Me(e2) && !xe(e2) || !("family" in e2) && !("graphite" in e2)), `${t2}: expect ${a2} to be a unit (store, event or effect)${n2}`);
var Ce = (e2, r2, a2) => {
  Array.isArray(e2) ? t(e2, (e3, t2) => je(e3, r2, `${t2} item of ${a2}`, "")) : je(e2, r2, a2, " or array of units");
};
var Ae = (e2, r2, a2 = "target") => t(Se(r2), (t2) => se(!J(t2, "derived"), `${e2}: derived unit in "${a2}"`, "createEvent/createStore"));
var Ie = (e2, { fn: t2 }, { a: r2 }) => t2(e2, r2);
var Oe = (e2, { fn: t2 }, { a: r2 }) => t2(r2, e2);
var qe = (e2, { fn: t2 }) => t2(e2);
var Ne = (e2, t2, r2, a2) => {
  let n2 = { id: ce(), type: e2, data: t2 };
  return r2 && (n2.order = { priority: r2 }, a2 && (n2.order.barrierID = ++Fe)), n2;
};
var Fe = 0;
var Re = ({ from: e2 = "store", store: t2, target: r2, to: a2 = r2 ? "store" : P, batch: n2, priority: i2 }) => Ne("mov", { from: e2, store: t2, to: a2, target: r2 }, i2, n2);
var De = ({ fn: e2, batch: t2, priority: r2, safe: a2 = 0, filter: n2 = 0, pure: i2 = 0 }) => Ne("compute", { fn: e2, safe: a2, filter: n2, pure: i2 }, r2, t2);
var Ee = ({ fn: e2 }) => De({ fn: e2, priority: "effect" });
var _e = (e2, t2, r2) => De({ fn: e2, safe: 1, filter: t2, priority: r2 && "effect" });
var Pe = (e2, t2, r2) => Re({ store: e2, to: t2 ? P : "a", priority: r2 && "sampler", batch: 1 });
var Le = (e2 = qe, t2) => De({ fn: e2, pure: 1, filter: t2 });
var Te = { mov: Re, compute: De, filter: ({ fn: e2, pure: t2 }) => De({ fn: e2, filter: 1, pure: t2 }), run: Ee };
var Be = (e2) => ({ id: ce(), current: e2 });
var We = ({ current: e2 }) => e2;
var He = (e2, t2) => {
  e2.before || (e2.before = []), le(e2.before, t2);
};
var Ue = null;
var Ve = (e2, t2) => {
  if (!e2)
    return t2;
  if (!t2)
    return e2;
  let r2;
  return (e2.v.type === t2.v.type && e2.v.id > t2.v.id || Ye(e2.v.type) > Ye(t2.v.type)) && (r2 = e2, e2 = t2, t2 = r2), r2 = Ve(e2.r, t2), e2.r = e2.l, e2.l = r2, e2;
};
var Ge = [];
var Je = 0;
for (; Je < 6; )
  le(Ge, { first: null, last: null, size: 0 }), Je += 1;
var Ke = () => {
  for (let e2 = 0; e2 < 6; e2++) {
    let t2 = Ge[e2];
    if (t2.size > 0) {
      if (3 === e2 || 4 === e2) {
        t2.size -= 1;
        let e3 = Ue.v;
        return Ue = Ve(Ue.l, Ue.r), e3;
      }
      1 === t2.size && (t2.last = null);
      let r2 = t2.first;
      return t2.first = r2.r, t2.size -= 1, r2.v;
    }
  }
};
var Qe = (e2, t2, r2, a2, n2, i2, o2) => Xe(0, { a: null, b: null, node: r2, parent: a2, value: n2, page: t2, scope: i2, meta: o2 }, e2);
var Xe = (e2, t2, r2, a2 = 0) => {
  let n2 = Ye(r2), i2 = Ge[n2], o2 = { v: { idx: e2, stack: t2, type: r2, id: a2 }, l: null, r: null };
  3 === n2 || 4 === n2 ? Ue = Ve(Ue, o2) : (0 === i2.size ? i2.first = o2 : i2.last.r = o2, i2.last = o2), i2.size += 1;
};
var Ye = (e2) => {
  switch (e2) {
    case "child":
      return 0;
    case "pure":
      return 1;
    case "read":
      return 2;
    case "barrier":
      return 3;
    case "sampler":
      return 4;
    case "effect":
      return 5;
    default:
      return -1;
  }
};
var Ze = /* @__PURE__ */ new Set();
var et;
var tt = 1;
var rt = 0;
var at = 0;
var nt = null;
var ot = (e2) => {
  et = e2;
};
var lt = (e2) => {
  nt = e2;
};
var st = (e2, t2) => {
  if (e2) {
    for (; e2 && !e2.reg[t2]; )
      e2 = V(e2);
    if (e2)
      return e2;
  }
  return null;
};
var ft;
var dt = (e2, t2, r2, a2, n2) => {
  let i2 = st(e2, a2.id);
  return i2 ? i2.reg[a2.id] : t2 ? (pt(t2, a2, n2), t2.reg[a2.id]) : a2;
};
var ut = (e2) => {
  ft = e2;
};
var ct = (e2) => e2;
var pt = (e2, r2, a2, n2, i2) => {
  var o2;
  let l2 = e2.reg, s2 = r2.sid, f2 = null == r2 || null === (o2 = r2.meta) || void 0 === o2 ? void 0 : o2.serialize;
  if (l2[r2.id])
    return;
  let d2 = { id: r2.id, current: r2.current, meta: r2.meta };
  if (s2 && s2 in e2.values.sidMap && !(s2 in e2.sidIdMap))
    d2.current = (e2.fromSerialize && "ignore" !== f2 && (null == f2 ? void 0 : f2.read) || ct)(e2.values.sidMap[s2]);
  else if (d2.id in e2.values.idMap)
    d2.current = e2.values.idMap[d2.id];
  else if (r2.before && !i2) {
    let i3 = 0, o3 = a2 || !r2.noInit || n2;
    t(r2.before, (t2) => {
      switch (t2.type) {
        case _: {
          let r3 = t2.from;
          if (r3 || t2.fn) {
            r3 && pt(e2, r3, a2, n2);
            let i4 = r3 && l2[r3.id].current;
            o3 && (d2.current = t2.fn ? t2.fn(i4) : i4);
          }
          break;
        }
        case "field":
          i3 || (i3 = 1, d2.current = Array.isArray(d2.current) ? [...d2.current] : { ...d2.current }), pt(e2, t2.from, a2, n2), o3 && (d2.current[t2.field] = l2[l2[t2.from.id].id].current);
      }
    });
  }
  s2 && (e2.sidIdMap[s2] = r2.id), l2[r2.id] = d2;
};
var mt = (e2, t2, r2) => {
  try {
    return t2(H(r2), e2.scope, r2);
  } catch (t3) {
    console.error(t3), e2.fail = 1, e2.failReason = t3;
  }
};
var gt = (t2, r2 = {}) => (Me(t2) && (gt(t2.or, r2), e(t2, (e2, t3) => {
  $e(e2) || "or" === t3 || "and" === t3 || (r2[t3] = e2);
}), gt(t2.and, r2)), r2);
var ht = (e2, t2) => {
  oe(e2.next, t2), oe(T(e2), t2), oe(B(e2), t2);
};
var yt = (e2, t2, r2) => {
  let a2;
  e2.next.length = 0, e2.seq.length = 0, e2.scope = null;
  let n2 = B(e2);
  for (; a2 = n2.pop(); )
    ht(a2, e2), (t2 || r2 && "sample" !== J(e2, "op") || "crosslink" === a2.family.type) && yt(a2, t2, "on" !== J(a2, "op") && r2);
  for (n2 = T(e2); a2 = n2.pop(); )
    ht(a2, e2), r2 && "crosslink" === a2.family.type && yt(a2, t2, "on" !== J(a2, "op") && r2);
};
var vt = (e2) => e2.clear();
var bt = (e2, { deep: t2 } = {}) => {
  let r2 = 0;
  if (e2.ownerSet && e2.ownerSet.delete(e2), Z(e2))
    vt(U(e2));
  else if (re(e2)) {
    r2 = 1;
    let t3 = e2.history;
    vt(t3.events), vt(t3.effects), vt(t3.stores), vt(t3.domains);
  }
  yt(L(e2), !!t2, r2);
};
var kt = (e2) => {
  let t2 = () => bt(e2);
  return t2.unsubscribe = t2, t2;
};
var wt = (e2, t2, r2, a2, i2) => n({ node: r2, parent: e2, child: t2, scope: { fn: i2 }, meta: { op: a2 }, family: { owners: [e2, t2], links: t2 }, regional: 1 });
var St = (e2) => {
  let t2 = "forward", [{ from: r2, to: a2 }, i2] = f(e2, 1);
  return Ce(r2, t2, '"from"'), Ce(a2, t2, '"to"'), Ae(t2, a2, "to"), kt(n({ parent: r2, child: a2, meta: { op: t2, config: i2 }, family: {}, regional: 1 }));
};
var Mt = (e2, t2) => (r(xe(t2), ".watch argument should be a function"), kt(n({ scope: { fn: t2 }, node: [Ee({ fn: qe })], parent: e2, meta: { op: "watch" }, family: { owners: e2 }, regional: 1 })));
var xt = (e2, t2, r2 = "event") => {
  V(e2) && V(e2).hooks[r2](t2);
};
var $t = (e2, t2, r2) => {
  let a2 = gt(r2), n2 = "domain" === e2, i2 = ue(), { sid: o2 = null, named: l2 = null, domain: f2 = null, parent: d2 = f2 } = a2, u2 = l2 || a2.name || (n2 ? "" : i2), c2 = s(u2, d2), p2 = { op: t2.kind = e2, name: t2.shortName = u2, sid: t2.sid = be(o2), named: l2, unitId: t2.id = i2, serialize: a2.serialize, derived: a2.derived, config: a2 };
  if (t2.parent = d2, t2.compositeName = c2, t2.defaultConfig = a2, t2.thru = (e3) => (se(0, "thru", "js pipe"), e3(t2)), t2.getType = () => c2.fullName, !n2) {
    t2.subscribe = (e4) => (ze(e4), t2.watch(xe(e4) ? e4 : (t3) => e4.next && e4.next(t3))), t2[E] = () => t2;
    let e3 = ve();
    e3 && (p2.nativeTemplate = e3);
  }
  return p2;
};
var zt = (e2, t2, r2, a2) => {
  let n2;
  Me(r2) && (n2 = r2, r2 = r2.fn);
  let i2 = u({ name: `${e2.shortName} → *`, derived: 1, and: n2 });
  return wt(e2, i2, a2, t2, r2), i2;
};
var jt = (e2, t2, r2, a2, n2) => {
  let i2 = W(t2), o2 = Re({ store: i2, to: "a", priority: "read" });
  r2 === _ && (o2.data.softRead = 1);
  let l2 = [o2, Le(a2)];
  return d("storeOnMap", i2, l2, Z(e2) && W(e2)), wt(e2, t2, l2, r2, n2);
};
var Ct = (t2, a2, n2, i2, l2) => {
  let s2 = t2 ? (e2) => [...e2] : (e2) => ({ ...e2 }), f2 = t2 ? [] : {}, u2 = s2(f2), c2 = Be(u2), m2 = Be(1);
  c2.type = t2 ? "list" : "shape", c2.noInit = 1, d("combineBase", c2, m2);
  let g2 = p(u2, { name: o(n2), derived: 1, and: i2 }), h2 = W(g2);
  h2.noInit = 1, K(g2, "isCombine", 1);
  let y2 = Pe(c2);
  y2.order = { priority: "barrier" };
  let v2 = [_e((e2, t3, r2) => (r2.scope && !r2.scope.reg[c2.id] && (r2.c = 1), e2)), y2, Re({ store: m2, to: "b" }), _e((e2, { key: t3 }, r2) => {
    if (r2.c || e2 !== r2.a[t3])
      return a2 && r2.b && (r2.a = s2(r2.a)), r2.a[t3] = e2, 1;
  }, 1), Re({ from: "a", target: c2 }), Re({ from: "value", store: 0, target: m2 }), Re({ from: "value", store: 1, target: m2, priority: "barrier", batch: 1 }), Pe(c2, 1), l2 && Le()];
  return e(n2, (e2, t3) => {
    if (!Z(e2))
      return r(!X(e2) && !$e(e2), `combine expects a store in a field ${t3}`), void (u2[t3] = f2[t3] = e2);
    f2[t3] = e2.defaultState, u2[t3] = e2.getState();
    let a3 = wt(e2, g2, v2, "combine", l2);
    a3.scope.key = t3;
    let n3 = W(e2);
    He(c2, { type: "field", field: t3, from: n3 }), d("combineField", n3, a3);
  }), g2.defaultShape = n2, He(h2, { type: _, from: c2, fn: l2 }), ve() || (g2.defaultState = l2 ? h2.current = l2(u2) : f2), g2;
};
var At = (e2, t2, r2) => {
  try {
    return [1, e2(...r2)];
  } catch (e3) {
    return t2(e3), [0, null];
  }
};
var It = (e2) => {
  let t2 = G(e2), r2 = { ref: t2 };
  return t2 && le(t2.activeEffects, r2), r2;
};
var Ot = (e2, t2, r2, a2, n2, o2) => (l2) => {
  o2.ref && oe(o2.ref.activeEffects, o2), i({ target: [a2, qt], params: [r2 ? { status: "done", params: e2, result: l2 } : { status: "fail", params: e2, error: l2 }, { value: l2, fn: r2 ? t2.rs : t2.rj }], defer: 1, page: n2.page, scope: o2.ref, meta: n2.meta });
};
var qt = n({ node: [Ee({ fn: ({ fn: e2, value: t2 }) => e2(t2) })], meta: { op: "fx", fx: "sidechain" } });
var Nt = ["source", "clock", "target"];
var Ft = (e2, t2) => e2 + `: ${t2} should be defined`;
var Rt = (e2, t2, a2, n2, i2, o2, l2, s2, f2, c2, g2, h2) => {
  let y2 = !!i2;
  r(!$e(a2) || !$e(t2), Ft(e2, "either source or clock"));
  let v2 = 0;
  $e(a2) ? v2 = 1 : X(a2) || (a2 = m(a2)), $e(t2) ? t2 = a2 : (Ce(t2, e2, "clock"), Array.isArray(t2) && (t2 = S(t2))), v2 && (a2 = t2), s2 || l2 || (l2 = a2.shortName);
  let b2 = "none";
  (g2 || n2) && (X(n2) ? b2 = "unit" : (r(xe(n2), "`filter` should be function or unit"), b2 = "fn")), i2 ? (Ce(i2, e2, "target"), Ae(e2, i2)) : "none" === b2 && c2 && Z(a2) && Z(t2) ? i2 = p(o2 ? o2(We(W(a2)), We(W(t2))) : We(W(a2)), { name: l2, sid: h2, or: s2 }) : (i2 = u({ name: l2, derived: 1, or: s2 }), d("sampleTarget", L(i2)));
  let k2 = Be(), w2 = [];
  if ("unit" === b2) {
    let [r2, a3] = Et(n2, i2, t2, k2, e2);
    w2 = [...Dt(a3), ...Dt(r2)];
  }
  let [M2, x2] = Et(a2, i2, t2, k2, e2), $2 = wt(t2, i2, [d("sampleSourceLoader"), Re({ from: P, target: k2 }), ...Dt(x2), Pe(M2, 1, f2), ...w2, Pe(k2), "fn" === b2 && Le((e3, t3, { a: r2 }) => n2(e3, r2), 1), o2 && Le(Ie), d("sampleSourceUpward", y2)], e2, o2);
  return we(a2, [$2]), Object.assign($2.meta, s2, { joint: 1 }), i2;
};
var Dt = (e2) => [Pe(e2), _e((e3, t2, { a: r2 }) => r2, 1)];
var Et = (e2, t2, r2, a2, i2) => {
  let o2 = Z(e2), l2 = o2 ? W(e2) : Be(), s2 = Be(o2);
  return o2 || n({ parent: e2, node: [Re({ from: P, target: l2 }), Re({ from: "value", store: 1, target: s2 })], family: { owners: [e2, t2, r2], links: t2 }, meta: { op: i2 }, regional: 1 }), d("sampleSource", s2, l2, a2), [l2, s2];
};
var _t = (e2, t2, r2, a2) => {
  let n2 = e2[t2];
  n2 && i({ target: n2, params: Array.isArray(n2) ? n2.map(() => r2) : r2, defer: 1, stack: a2 });
};
var Pt = "22.8.3";
var Lt = (e2) => e2;

export {
  a,
  n,
  i,
  l,
  u,
  p,
  m,
  g,
  y,
  v,
  b,
  k,
  w,
  S,
  x,
  $,
  z,
  j,
  C,
  O,
  q,
  N,
  F,
  R,
  ne,
  ge,
  ke,
  Te,
  ut,
  bt,
  St,
  Pt
};
//# sourceMappingURL=chunk-7MQMNHLI.js.map
