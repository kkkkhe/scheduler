{"version":3,"file":"atomic-router.cjs.js","sources":["../src/methods/create-route.ts","../src/utils/equals.ts","../src/utils/build-path.ts","../src/utils/history-effects.ts","../src/utils/logic.ts","../src/methods/redirect.ts","../src/types.ts","../src/methods/create-router-controls.ts","../src/methods/is-route.ts","../src/methods/new-create-history-router.ts","../src/methods/query-sync.ts","../src/methods/chain-route.ts","../src/utils/remap-route-objects.ts"],"sourcesContent":["import {\n  attach,\n  createEffect,\n  createEvent,\n  createStore,\n  split,\n  Store,\n} from 'effector';\nimport {\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n  RouteInstance,\n  NavigateParams,\n  Kind,\n  EmptyObject,\n} from '../types';\n\ntype CreateRouteParams = {\n  filter?: Store<boolean>;\n};\n\nexport function createRoute<Params extends RouteParams = {}>(\n  params: CreateRouteParams = {}\n): RouteInstance<Params> {\n  const navigateFx = createEffect<\n    NavigateParams<Params>,\n    NavigateParams<Params>\n  >(({ params, query, replace = false }) => ({\n    params: params || {},\n    query: query || {},\n    replace,\n  }));\n\n  const openFx = attach({\n    effect: navigateFx,\n    mapParams: (params: Params extends EmptyObject ? void : Params) => ({\n      params: (params || {}) as Params,\n      query: {} as RouteQuery,\n    }),\n  });\n\n  const $isOpened = createStore<boolean>(false);\n  const $params = createStore<Params>({} as Params);\n  const $query = createStore<RouteQuery>({});\n\n  const opened = createEvent<RouteParamsAndQuery<Params>>();\n  const updated = createEvent<RouteParamsAndQuery<Params>>();\n  const closed = createEvent<void>();\n\n  $isOpened.on(opened, () => true).on(closed, () => false);\n\n  $params\n    .on(opened, (_, { params }) => params)\n    .on(updated, (_, { params }) => params);\n\n  $query\n    .on(opened, (_, { query }) => query)\n    .on(updated, (_, { query }) => query);\n\n  split({\n    source: navigateFx.doneData,\n    match: $isOpened.map((isOpened) => (isOpened ? 'updated' : 'opened')),\n    cases: {\n      opened,\n      updated,\n    },\n  });\n\n  // if (params.filter) {\n  //   const filter = params.filter;\n  //   split({\n  //     // @ts-expect-error\n  //     source: sample({ clock: filter }),\n  //     // @ts-expect-error\n  //     match: (filter) => (filter ? 'true' : 'false'),\n  //     cases: {\n  //       true: opened,\n  //       false: closed,\n  //     },\n  //   });\n  // }\n\n  const instance: RouteInstance<Params> = {\n    $isOpened,\n    $params,\n    $query,\n    opened,\n    updated,\n    closed,\n    navigate: navigateFx,\n    open: openFx,\n    kind: Kind.ROUTE,\n    // @ts-expect-error Internal stuff\n    settings: {\n      derived: Boolean(params.filter),\n    },\n  };\n\n  return instance;\n}\n","export function paramsEqual(a: Record<string, any>, b: Record<string, any>) {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const k in a) {\n    // NOTE: Parsed URI always returns string parameters\n    // so we force string comparison here\n    // in order to avoid extra updates\n    // whenever user passes numeric params\n    if (`${a[k]}` !== `${b[k]}`) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { match, compile } from 'path-to-regexp';\n\nimport {\n  RouteParams,\n  PathCreator,\n  RouteQuery,\n  ParamsSerializer,\n} from '../types';\n\n// NOTE: If path is URL - provide it as is\n// Otherwise - extract pathname and hash\nconst getComparablePath = (path: string) => {\n  if (path.match(/^[a-z0-9]+\\:\\/\\//i)) {\n    return path;\n  }\n  const url = new URL(`http://_${path}`);\n  return [url.pathname, url.hash].join('');\n};\n\n// NOTE: path-to-regexp treats \":\" in \"https://\" as param start\n// So we escape it\nfunction normalizePathCreator(pathCreator: string) {\n  return pathCreator.replace('://', '\\\\://');\n}\n\ntype BuildPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  params: Params;\n  query: RouteQuery;\n  serialize?: ParamsSerializer;\n};\nexport function buildPath<Params extends RouteParams>({\n  pathCreator,\n  params,\n  query,\n  serialize,\n}: BuildPathParams<Params>) {\n  const pathname = compile(pathCreator)(params);\n  const serializedParams =\n    serialize?.write(query) ?? new URLSearchParams(query);\n  const qs = Object.keys(query).length ? `?${serializedParams}` : '';\n  const url = `${pathname}${qs}`;\n  return url;\n}\n\ntype MatchPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  actualPath: string;\n};\nexport function matchPath<Params extends RouteParams>({\n  pathCreator,\n  actualPath,\n}: MatchPathParams<Params>) {\n  const matches = match(normalizePathCreator(pathCreator))(\n    getComparablePath(actualPath)\n  );\n  if (matches) {\n    return { matches: true, params: matches.params } as const;\n  }\n  return { matches: false } as const;\n}\n","import { History } from 'history';\nimport { createEffect } from 'effector';\n\nimport { HistoryBackForwardParams, HistoryPushParams } from '../types';\n\nfunction assertHistory(history: History) {\n  if (!history) {\n    throw new Error('[Routing] No history provided');\n  }\n}\n\nexport const historyPushFx = createEffect((params: HistoryPushParams) => {\n  assertHistory(params.history);\n  params.history[params.method](params.path, {});\n  return params;\n});\n\nexport const historyBackFx = createEffect(\n  (history: HistoryBackForwardParams) => {\n    assertHistory(history);\n    history.back();\n    return history;\n  }\n);\n\nexport const historyForwardFx = createEffect(\n  (history: HistoryBackForwardParams) => {\n    assertHistory(history);\n    history.forward();\n    return history;\n  }\n);\n","import { Store } from 'effector';\n\nexport function not<T>(source: Store<T>): Store<boolean> {\n  return source.map((value) => !value);\n}\n","import {\n  Clock,\n  createEvent,\n  createStore,\n  Event,\n  is,\n  sample,\n  Store,\n} from 'effector';\nimport { EmptyObject, RouteInstance, RouteParams, RouteQuery } from '../types';\n\ntype RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject\n  ? {\n      clock?: Clock<T>;\n      route: RouteInstance<Params>;\n      query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n      replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n    }\n  :\n      | {\n          clock?: Clock<T>;\n          route: RouteInstance<Params>;\n          params: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        }\n      | {\n          clock?: Clock<{\n            params: Params;\n            query?: RouteQuery;\n            replace?: boolean;\n          }>;\n          route: RouteInstance<Params>;\n          params?: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        };\n\n/** Opens passed `route` upon `clock` trigger */\nexport function redirect<T, Params extends RouteParams>(\n  options: RedirectParams<T, Params>\n) {\n  const clock = options.clock\n    ? sample({ clock: options.clock as Event<T> })\n    : createEvent<T>();\n\n  let params = toStore(options.params || {});\n  let query = toStore(options.query || {});\n  // @ts-expect-error\n  let replace = toStore(options.replace || false);\n\n  sample({\n    clock: clock,\n    source: { params, query, replace },\n    fn: ({ params, query, replace }, clock) => ({\n      params: typeof params === 'function' ? params(clock) : params,\n      query: typeof query === 'function' ? query(clock) : query,\n      replace: typeof replace === 'function' ? replace(clock) : replace,\n    }),\n    target: options.route.navigate,\n  });\n  return clock;\n}\n\nfunction toStore<T>(payload: T | Store<T>): Store<T> {\n  return is.store(payload) ? payload : createStore(payload as T);\n}\n","import { History } from 'history';\nimport { Effect, Event, Store } from 'effector';\n\nexport type RouteParams = Record<string, any>;\n\nexport type RouteQuery = Record<string, any>;\n\nexport type RouteParamsAndQuery<Params extends RouteParams> = {\n  params: Params;\n  query: RouteQuery;\n};\n\nexport interface NavigateParams<Params extends RouteParams>\n  extends RouteParamsAndQuery<Params> {\n  replace?: boolean;\n}\n\nexport type RouteInstance<Params extends RouteParams> = {\n  $isOpened: Store<boolean>;\n  $params: Store<Params>;\n  $query: Store<RouteQuery>;\n  opened: Event<RouteParamsAndQuery<Params>>;\n  updated: Event<RouteParamsAndQuery<Params>>;\n  closed: Event<void>;\n  navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;\n  open: Effect<\n    Params extends EmptyObject ? void : Params,\n    RouteParamsAndQuery<Params>\n  >;\n  kind: typeof Kind.ROUTE;\n};\n\nexport type RouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  path: string;\n};\n\nexport type UnmappedRouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params> | RouteInstance<Params>[];\n  path: string;\n};\n\nexport type HistoryPushParams = {\n  history: History;\n  path: string;\n  params: RouteParams;\n  query: RouteQuery;\n  method: 'replace' | 'push';\n};\n\nexport type HistoryBackForwardParams = History;\n\nexport type ParamsSerializer = {\n  write: (params: RouteParams) => string;\n  read: (query: string) => RouteParams;\n};\n\n// @ts-expect-error\nexport type PathCreator<Params extends RouteParams> = string;\n\nexport const Kind = {\n  ROUTE: Symbol(),\n};\n\nexport type EmptyObject = { [key in string]: never };\n","import { createEvent, createStore } from 'effector';\n\nimport { RouteQuery } from '../types';\nimport { paramsEqual } from '../utils/equals';\n\nexport const createRouterControls = () => {\n  return {\n    $query: createStore<RouteQuery>(\n      {},\n      {\n        updateFilter: (update, current) => !paramsEqual(current, update),\n      }\n    ),\n    back: createEvent(),\n    forward: createEvent(),\n  };\n};\n","import { Kind, RouteInstance } from '../types';\n\n/** Detects whether passed value is a `RouteInstance<any>` or not */\nexport const isRoute = (\n  route: RouteInstance<any> | unknown\n): route is RouteInstance<any> => {\n  return (\n    typeof route === 'object' &&\n    route !== null &&\n    'kind' in route &&\n    // @ts-expect-error\n    route.kind === Kind.ROUTE\n  );\n};\n","import { History } from 'history';\nimport { attach, createEvent, createStore, sample, scopeBind } from 'effector';\nimport { createRouterControls } from './create-router-controls';\nimport {\n  HistoryPushParams,\n  ParamsSerializer,\n  RouteInstance,\n  RouteObject,\n  RouteParams,\n  RouteQuery,\n  UnmappedRouteObject,\n} from '../types';\nimport { remapRouteObjects } from '../utils/remap-route-objects';\nimport { paramsEqual } from '../utils/equals';\nimport { buildPath, matchPath } from '../utils/build-path';\nimport { isRoute } from './is-route';\nimport {\n  historyBackFx,\n  historyForwardFx,\n  historyPushFx,\n} from '../utils/history-effects';\nimport { not } from '../utils/logic';\n\nexport function createHistoryRouter({\n  base,\n  routes,\n  notFoundRoute,\n  hydrate,\n  serialize,\n  controls = createRouterControls(),\n}: {\n  base?: string;\n  routes: UnmappedRouteObject<any>[];\n  notFoundRoute?: RouteInstance<any>;\n  serialize?: ParamsSerializer;\n  hydrate?: boolean;\n  controls?: ReturnType<typeof createRouterControls>;\n}) {\n  const remappedRoutes = remapRouteObjects(routes, base);\n\n  const setHistory = createEvent<History>();\n  const navigateFromRouteTriggered = createEvent<{\n    route: RouteObject<any>;\n    params: RouteParams;\n    query: RouteQuery;\n    replace: boolean;\n  }>();\n  const historyUpdated = createEvent();\n  const recalculateTriggered = createEvent<{\n    path: string;\n    query: RouteQuery;\n    hash: string;\n  }>();\n  const recalculated = createEvent<{\n    path: string;\n    query: RouteQuery;\n    matching: RecalculationResult<any>[];\n    mismatching: RecalculationResult<any>[];\n  }>();\n  const routesMatched = createEvent<RecalculationResult<any>[]>();\n  const routesMismatched = createEvent<RecalculationResult<any>[]>();\n  const routeNotFound = createEvent();\n  const initialized = createEvent<{\n    activeRoutes: RouteInstance<any>[];\n    path: string;\n    query: RouteQuery;\n  }>();\n\n  const $path = createStore('');\n  const $query = createStore<RouteQuery>(\n    {},\n    {\n      name: 'historyRouter.$query',\n      updateFilter: (newQuery, oldQuery) => !paramsEqual(newQuery, oldQuery),\n    }\n  );\n  const $activeRoutes = createStore<RouteInstance<any>[]>([], {\n    serialize: 'ignore',\n  });\n  // @ts-expect-error\n  const $history = createStore<History>(null, {\n    serialize: 'ignore',\n  });\n  const $isFirstCheckPassed = createStore(false);\n  const $isRouteNavigateInProgress = createStore(false);\n\n  const pushFx = attach({\n    source: $history,\n    effect(history, params: Omit<HistoryPushParams, 'history'>) {\n      return historyPushFx({\n        history,\n        ...params,\n      });\n    },\n  });\n\n  const subscribeHistoryFx = attach({\n    source: $history,\n    effect(history) {\n      let scopedHistoryUpdated = historyUpdated;\n      try {\n        // @ts-expect-error\n        scopedHistoryUpdated = scopeBind(historyUpdated);\n      } catch (err) {}\n      history.listen(() => {\n        scopedHistoryUpdated();\n      });\n      return true;\n    },\n  });\n\n  const historyUpdatedParsed = sample({\n    clock: hydrate\n      ? [historyUpdated]\n      : [historyUpdated, subscribeHistoryFx.done],\n    source: $history,\n    filter: Boolean,\n    fn: (history) => ({\n      path: history.location.pathname,\n      query:\n        serialize?.read(history.location.search) ??\n        Object.fromEntries(new URLSearchParams(history.location.search)),\n    }),\n  });\n\n  // If `hydrate` flag is set,\n  // don't trigger recheck on history init\n  const historyUpdateTriggered = sample({\n    clock: historyUpdatedParsed,\n    source: {\n      path: $path,\n      query: $query,\n    },\n    filter: ({ path: savedPath, query: savedQuery }, history) =>\n      history.path !== savedPath || !paramsEqual(history.query, savedQuery),\n    fn: (_, history) => history,\n  });\n\n  /// History subscription\n  $history.on(setHistory, (_, history) => history);\n\n  sample({\n    clock: $history,\n    target: subscribeHistoryFx,\n  });\n\n  sample({\n    clock: historyUpdateTriggered,\n    source: $history,\n    filter: Boolean,\n    fn(history) {\n      const path = history?.location.pathname;\n      const hash = history?.location.hash;\n      const query: RouteQuery =\n        serialize?.read(history?.location.search) ??\n        Object.fromEntries(new URLSearchParams(history?.location.search));\n      return { path, query, hash };\n    },\n    target: recalculateTriggered,\n  });\n\n  /// Routes updates handling\n  for (const routeObj of remappedRoutes) {\n    const currentRouteMatched = routesMatched.filterMap(\n      containsCurrentRoute(routeObj)\n    );\n    const currentRouteMismatched = routesMismatched.filterMap(\n      containsCurrentRoute(routeObj)\n    );\n    const routeStateChangeRequested = {\n      opened: sample({\n        clock: currentRouteMatched,\n        filter: not(routeObj.route.$isOpened),\n      }),\n      updated: sample({\n        clock: currentRouteMatched,\n        filter: routeObj.route.$isOpened,\n      }),\n      closed: sample({\n        clock: currentRouteMismatched,\n        filter: routeObj.route.$isOpened,\n      }),\n    };\n\n    // Trigger .updated() for the routes marked as \"matched\" but already opened\n    sample({\n      clock: routeStateChangeRequested.updated,\n      source: [routeObj.route.$params, routeObj.route.$query],\n      // Skip .updated() calls if params & query are the same\n      filter: ([params, query], next) =>\n        !paramsEqual(params, next.params) || !paramsEqual(query, next.query),\n      fn: (_, paramsAndQuery) => paramsAndQuery,\n      target: routeObj.route.updated,\n    });\n\n    // Trigger .opened() for the routes marked as \"matched\" but not opened yet\n    sample({\n      clock: routeStateChangeRequested.opened,\n      // TODO: Scratch this?\n      filter: not($isRouteNavigateInProgress),\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .closed() for the routes marked as \"mismatched\" but opened\n    sample({\n      clock: routeStateChangeRequested.closed,\n      target: routeObj.route.closed,\n    });\n  }\n\n  /// Handling route.navigateFx navigation\n  for (const routeObj of remappedRoutes) {\n    // Run \"Handling route.navigateFx navigation\" step\n    sample({\n      clock: routeObj.route.navigate.doneData,\n      fn: ({ params, query, replace }) => ({\n        route: routeObj,\n        params,\n        query,\n        replace: replace ?? false,\n      }),\n      target: navigateFromRouteTriggered,\n    });\n  }\n\n  $isRouteNavigateInProgress.on(navigateFromRouteTriggered, () => true);\n\n  sample({\n    clock: navigateFromRouteTriggered,\n    fn({ route, params, query, replace }) {\n      const path = buildPath({\n        pathCreator: route.path,\n        params,\n        query,\n        serialize,\n      });\n      const method: 'replace' | 'push' = replace ? 'replace' : 'push';\n      return {\n        path,\n        params,\n        query,\n        method,\n      };\n    },\n    target: pushFx,\n  });\n\n  $isRouteNavigateInProgress.reset([routesMatched, routesMismatched]);\n\n  /// Recalculation\n  // Triggered on every history change + once when history instance is set\n  sample({\n    clock: recalculateTriggered,\n    fn({ path, query, hash }) {\n      const matchingRoutes = [] as RecalculationResult<any>[];\n      const mismatchingRoutes = [] as RecalculationResult<any>[];\n\n      for (const route of remappedRoutes) {\n        // NOTE: Use hash string as well if route.path contains #\n        const actualPath = route.path.includes('#')\n          ? `${path}${hash}`\n          : `${path}`;\n        const { matches, params } = matchPath({\n          pathCreator: route.path,\n          actualPath,\n        });\n\n        const suitableRoutes = matches ? matchingRoutes : mismatchingRoutes;\n        suitableRoutes.push({\n          routeObj: route,\n          params,\n          query,\n        });\n      }\n\n      // Checking for routes we need to close\n      // Remove all that are marked to be opened\n      mismatchingRoutes.forEach((mismatchedRoute, mismatchedIndex) => {\n        const mismatchedRouteExistsInMatchedList = matchingRoutes.some(\n          (matchedRoute) =>\n            matchedRoute.routeObj.route === mismatchedRoute.routeObj.route\n        );\n        if (mismatchedRouteExistsInMatchedList) {\n          mismatchingRoutes.splice(mismatchedIndex, 1);\n        }\n      });\n\n      return {\n        matching: matchingRoutes,\n        mismatching: mismatchingRoutes.filter(Boolean),\n        path,\n        query,\n      };\n    },\n    target: recalculated,\n  });\n\n  $path.on(historyUpdateTriggered, (_, { path }) => path);\n\n  $query.on(historyUpdateTriggered, (_, { query }) => query);\n\n  const matchingRecalculated = recalculated.map(({ matching }) => matching);\n\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length > 0,\n    target: routesMatched,\n  });\n\n  sample({\n    clock: recalculated.map(({ mismatching }) => mismatching),\n    filter: (routes) => routes.length > 0,\n    target: routesMismatched,\n  });\n\n  $activeRoutes.on(recalculated, (_, { matching }) =>\n    matching.map((recheckResult) => recheckResult.routeObj.route)\n  );\n\n  /// Handling 404\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length === 0,\n    target: routeNotFound,\n  });\n\n  if (isRoute(notFoundRoute)) {\n    sample({\n      clock: routeNotFound,\n      source: $query,\n      filter: notFoundRoute.$isOpened,\n      fn: (query) => ({ query, params: {} }),\n      target: notFoundRoute.updated,\n    });\n\n    sample({\n      clock: routeNotFound,\n      source: { query: $query, isOpened: notFoundRoute.$isOpened },\n      filter: ({ isOpened }) => !isOpened,\n      fn: ({ query }) => ({ query, params: {} }),\n      target: notFoundRoute.opened,\n    });\n\n    sample({\n      clock: matchingRecalculated,\n      source: notFoundRoute.$isOpened,\n      filter: (isOpened, matching) => isOpened && matching.length > 0,\n      target: notFoundRoute.closed,\n    });\n  }\n\n  /// Back/forward navigation\n  sample({\n    clock: controls.back,\n    source: $history,\n    target: historyBackFx,\n  });\n\n  sample({\n    clock: controls.forward,\n    source: $history,\n    target: historyForwardFx,\n  });\n\n  /// Query syncing\n  sample({\n    clock: $query,\n    source: { controlsQuery: controls.$query, localQuery: $query },\n    filter: ({ controlsQuery, localQuery }) =>\n      !paramsEqual(controlsQuery, localQuery),\n    fn: ({ localQuery }) => localQuery,\n    target: controls.$query,\n  });\n\n  sample({\n    clock: controls.$query,\n    source: {\n      path: $path,\n      localQuery: $query,\n      isNavigateInProgress: $isRouteNavigateInProgress,\n      realHistory: $history,\n    },\n    filter: ({ localQuery, isNavigateInProgress, realHistory }, query) => {\n      const realQuery =\n        serialize?.read(realHistory?.location.search ?? '') ??\n        Object.fromEntries(\n          new URLSearchParams(realHistory?.location.search ?? '')\n        );\n      return (\n        isNavigateInProgress ||\n        !paramsEqual(query, realQuery) ||\n        !paramsEqual(localQuery, query)\n      );\n    },\n    fn({ path }, query) {\n      const qs = serialize?.write(query) ?? new URLSearchParams(query);\n      return {\n        path: `${path}${qs ? `?${qs}` : ''}`,\n        params: {},\n        query: query,\n        method: 'push' as const,\n      };\n    },\n    target: pushFx,\n  });\n\n  /// Initialization\n  sample({\n    clock: recalculated,\n    source: {\n      activeRoutes: $activeRoutes,\n      path: $path,\n      query: $query,\n    },\n    filter: $isFirstCheckPassed.map(\n      (isFirstCheckPassed) => !isFirstCheckPassed\n    ),\n    target: initialized,\n  });\n\n  $isFirstCheckPassed.on(initialized, () => true).reset($history);\n\n  return {\n    $path,\n    $activeRoutes,\n    $history,\n    setHistory,\n    $query: $query,\n    back: controls.back,\n    forward: controls.forward,\n    push: pushFx,\n    routes: remappedRoutes,\n    initialized,\n    routeNotFound,\n  };\n}\n\ntype RecalculationResult<Params extends RouteParams> = {\n  routeObj: RouteObject<Params>;\n  params: Params;\n  query: RouteQuery;\n};\n\nconst containsCurrentRoute =\n  (routeObj: RouteObject<any>) =>\n  (recheckResults: RecalculationResult<any>[]) => {\n    const recheck = recheckResults.find(\n      (recheckResult) => recheckResult.routeObj.route === routeObj.route\n    );\n    if (!recheck) {\n      return;\n    }\n    return {\n      params: recheck.params,\n      query: recheck.query,\n    };\n  };\n","import { Clock, combine, createStore, sample, Store, Unit } from 'effector';\n\nimport { RouteInstance, RouteQuery } from '../types';\nimport { createRouterControls } from './create-router-controls';\n\ntype QueryCleanupStrategy = {\n  irrelevant: boolean;\n  empty: boolean;\n  preserve: string[];\n};\n\ntype QuerySyncParams<T extends Record<string, Store<any>>> = {\n  source: T;\n  clock?: Clock<any>;\n  controls: ReturnType<typeof createRouterControls>;\n  route?: RouteInstance<any>;\n  cleanup?: boolean | Partial<QueryCleanupStrategy>;\n};\n\nexport function querySync<T extends Record<string, Store<any>>>(\n  params: QuerySyncParams<T>\n) {\n  const $isOpened = params.route?.$isOpened ?? createStore(true);\n  const $source = combine(params.source);\n  const clock = (params.clock ?? $source) as Unit<any>;\n  const cleanupStrategy = !('cleanup' in params)\n    ? cleanupStrategies.default\n    : typeof params.cleanup === 'boolean'\n    ? cleanupStrategies[params.cleanup ? 'all' : 'none']\n    : { ...cleanupStrategies.default, ...params.cleanup! };\n\n  const queryUpdatedFromHistory = sample({\n    clock: params.controls.$query,\n    filter: $isOpened,\n  });\n\n  sample({\n    clock,\n    source: combine([$source, params.controls.$query]),\n    filter: $isOpened,\n    fn: ([source, currentQuery]) => {\n      let nextQuery: RouteQuery = {};\n      if (cleanupStrategy.irrelevant) {\n        for (const key of cleanupStrategy.preserve) {\n          if (key in currentQuery) {\n            nextQuery[key] = currentQuery[key];\n          }\n        }\n      } else {\n        nextQuery = { ...currentQuery };\n      }\n      for (const key in source) {\n        nextQuery[key] = source[key];\n      }\n      if (cleanupStrategy.empty) {\n        for (const key in source) {\n          if (!cleanupStrategy.preserve.includes(key) && !nextQuery[key]) {\n            delete nextQuery[key];\n          }\n        }\n      }\n      return nextQuery as RouteQuery;\n    },\n    target: params.controls.$query,\n  });\n\n  for (const k in params.source) {\n    const $queryParam = params.source[k as keyof typeof params.source];\n    $queryParam.on(queryUpdatedFromHistory, (_, query) => {\n      return query[k] ?? $queryParam.defaultState;\n    });\n  }\n}\n\nconst cleanupStrategies = {\n  all: {\n    irrelevant: true,\n    empty: true,\n    preserve: [],\n  },\n  default: {\n    irrelevant: false,\n    empty: true,\n    preserve: [],\n  },\n  none: {\n    irrelevant: false,\n    empty: false,\n    preserve: [],\n  },\n};\n","import {\n  is,\n  guard,\n  merge,\n  sample,\n  combine,\n  createStore,\n  Unit,\n  Clock,\n  Effect,\n  StoreValue,\n  createEvent,\n  NoInfer,\n  EffectParams,\n  attach,\n} from 'effector';\n\nimport { createRoute } from './create-route';\nimport {\n  RouteInstance,\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n} from '../types';\n\nimport { isRoute } from './is-route';\n\ntype ChainRouteParamsInternalAttach<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: {\n    effect: FX;\n    mapParams: ({\n      params,\n      query,\n    }: {\n      params: Params;\n      query: RouteQuery;\n    }) => NoInfer<EffectParams<FX>>;\n  };\n  openOn?: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsWithEffect<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;\n};\n\ntype ChainRouteParamsAdvanced<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsNormalized<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn: Clock<any>;\n};\n\ntype chainRouteParams<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n> =\n  | RouteInstance<Params>\n  | ChainRouteParamsWithEffect<Params>\n  | ChainRouteParamsAdvanced<Params>\n  | ChainRouteParamsInternalAttach<Params, FX>;\n\nfunction normalizeChainRouteParams<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(params: chainRouteParams<Params, FX>): ChainRouteParamsNormalized<Params> {\n  const resultParams: ChainRouteParamsNormalized<Params> =\n    {} as ChainRouteParamsNormalized<Params>;\n  if (isRoute(params)) {\n    Object.assign(resultParams, {\n      route: params,\n      chainedRoute: createRoute<Params>(),\n      beforeOpen: createEvent(),\n      openOn: merge([params.opened, params.closed]),\n      cancelOn: merge([createEvent()]),\n    });\n    return resultParams;\n  }\n  const effectParams = params as ChainRouteParamsWithEffect<Params>;\n  Object.assign(resultParams, {\n    route: effectParams.route,\n    chainedRoute: effectParams.chainedRoute || createRoute<Params>(),\n    beforeOpen: is.unit(effectParams.beforeOpen)\n      ? effectParams.beforeOpen\n      : attach(effectParams.beforeOpen),\n  });\n  if (is.effect(resultParams.beforeOpen)) {\n    Object.assign(resultParams, {\n      openOn:\n        // @ts-expect-error\n        effectParams.openOn || resultParams.beforeOpen.doneData,\n      cancelOn:\n        // @ts-expect-error\n        effectParams.cancelOn || resultParams.beforeOpen.failData,\n    });\n    return resultParams;\n  }\n  const advancedParams = params as ChainRouteParamsAdvanced<Params>;\n  Object.assign(resultParams, {\n    openOn: sample({ clock: advancedParams.openOn as Unit<any> }),\n    cancelOn: sample({\n      clock: (advancedParams.cancelOn as Unit<any>) || createEvent(),\n    }),\n  });\n  return resultParams;\n}\n\nfunction chainRoute<Params extends RouteParams>(\n  instance: RouteInstance<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsWithEffect<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsAdvanced<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(config: ChainRouteParamsInternalAttach<Params, FX>): RouteInstance<Params>;\n\n/**\n * Creates chained route\n * @link https://github.com/Kelin2025/atomic-router/issues/10\n * @param {RouteInstance<any>} params.route - Route to listen\n * @param {RouteInstance<any>} [params.chainedRoute]  - Route to be created\n * @param {Clock<any>} params.beforeOpen - Will be triggered when `params.route` open\n * @param {Clock<any>} params.openOn - Will open `chainedRoute` if `params.route` is still opened\n * @param {Clock<any>} params.cancelOn - Cancels chain\n * @returns {RouteInstance<any>} `chainedRoute`\n */\nfunction chainRoute<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(params: chainRouteParams<Params, FX>) {\n  const { route, chainedRoute, beforeOpen, openOn, cancelOn } =\n    normalizeChainRouteParams(params);\n  const $params = createStore({} as StoreValue<typeof route['$params']>);\n  const $query = createStore({} as StoreValue<typeof route['$query']>);\n  const $hasSameParams = combine(\n    combine([route.$params, route.$query]),\n    combine([$params, $query]),\n    (current, stored) => {\n      return current[0] === stored[0] && current[1] === stored[1];\n    }\n  );\n  const routeOpened = sample({\n    clock: [route.opened, route.updated],\n  });\n  // 1. Call `beforeOpen` whenever route is opened\n  sample({\n    clock: routeOpened,\n    target: beforeOpen as Unit<RouteParamsAndQuery<any>>,\n  });\n  $params.on(routeOpened, (_prev, { params }) => params);\n  $query.on(routeOpened, (_prev, { query }) => query);\n  // 2. Listen to `openOn` if route is still opened on the same position\n  const chainedRouteResolved = guard({\n    clock: openOn,\n    source: { params: $params, query: $query },\n    filter: $hasSameParams,\n  });\n  sample({\n    clock: chainedRouteResolved,\n    target: chainedRoute.navigate,\n  });\n  // 4. Cancel loading if page closed or `cancelOn` is called\n  // @ts-expect-error\n  const aborted = merge([route.closed, cancelOn]);\n  $params.reset(aborted);\n  $query.reset(aborted);\n  sample({\n    clock: aborted,\n    target: chainedRoute.closed,\n  });\n  return chainedRoute;\n}\n\n// This is written separately to correctly export all type overloads\nexport { chainRoute };\n","import { UnmappedRouteObject, RouteObject } from '../types';\n\nexport function remapRouteObjects(\n  objects: UnmappedRouteObject<any>[],\n  basePath: string = ''\n) {\n  let next: RouteObject<any>[] = [];\n  for (const routeObj of objects) {\n    if (Array.isArray(routeObj.route)) {\n      next.push(...routeObj.route.map((route) => ({ ...routeObj, route })));\n    } else {\n      // @ts-expect-error\n      next.push(routeObj);\n    }\n  }\n  next = next.map((routeObj) => ({\n    ...routeObj,\n    path: `${basePath}${routeObj.path}`,\n  }));\n  const derivedRoutes: RouteObject<any>[] = [];\n  const nonDerivedRoutes: RouteObject<any>[] = [];\n  for (const routeObj of next) {\n    // @ts-expect-error Internals\n    if (routeObj.route.settings.derived) {\n      derivedRoutes.push(routeObj);\n    } else {\n      nonDerivedRoutes.push(routeObj);\n    }\n  }\n  if (derivedRoutes.length) {\n    for (const derivedRoute of derivedRoutes) {\n      console.error(\n        `createHistoryRouter: ${derivedRoute.path} uses derived route. This won't work`\n      );\n    }\n  }\n  return nonDerivedRoutes;\n}\n"],"names":["createRoute","params","navigateFx","createEffect","_ref","_ref$replace","replace","query","name","sid","openFx","attach","and","effect","mapParams","or","$isOpened","createStore","$params","$query","opened","createEvent","updated","closed","on","_","_ref2","_ref3","_ref4","_ref5","split","source","doneData","match","map","isOpened","cases","navigate","open","kind","Kind","ROUTE","settings","derived","Boolean","filter","paramsEqual","a","b","Object","keys","length","k","buildPath","_serialize$write","serialize","pathname","compile","pathCreator","serializedParams","write","URLSearchParams","matchPath","actualPath","matches","path","url","URL","hash","join","getComparablePath","assertHistory","history","Error","not","value","toStore","payload","is","store","Symbol","createRouterControls","updateFilter","update","current","back","forward","isRoute","route","historyPushFx","method","historyBackFx","historyForwardFx","containsCurrentRoute","routeObj","recheckResults","recheck","find","recheckResult","cleanupStrategies","all","irrelevant","empty","preserve","default","none","normalizeChainRouteParams","resultParams","_withFactory","fn","assign","chainedRoute","beforeOpen","openOn","merge","cancelOn","effectParams","unit","failData","advancedParams","sample","clock","$hasSameParams","combine","stored","routeOpened","target","_prev","chainedRouteResolved","guard","aborted","reset","base","routes","notFoundRoute","hydrate","_ref$controls","controls","remappedRoutes","objects","basePath","_step","next","_loop","_next","Array","isArray","push","_objectSpread","_iterator","_createForOfIteratorHelperLoose","done","_step2","derivedRoutes","nonDerivedRoutes","_iterator2","_step3","_iterator3","console","error","derivedRoute","remapRouteObjects","setHistory","navigateFromRouteTriggered","historyUpdated","recalculateTriggered","recalculated","routesMatched","routesMismatched","routeNotFound","initialized","$path","newQuery","oldQuery","$activeRoutes","$history","$isFirstCheckPassed","$isRouteNavigateInProgress","pushFx","subscribeHistoryFx","scopedHistoryUpdated","scopeBind","err","listen","historyUpdatedParsed","_serialize$read","location","read","search","fromEntries","historyUpdateTriggered","_serialize$read2","currentRouteMatched","filterMap","currentRouteMismatched","routeStateChangeRequested","_ref16","paramsAndQuery","_ref17","matchingRoutes","mismatchingRoutes","includes","_matchPath","forEach","mismatchedRoute","mismatchedIndex","some","matchedRoute","splice","matching","mismatching","_ref6","matchingRecalculated","_ref7","_ref8","_ref9","_ref10","_ref11","controlsQuery","localQuery","_ref12","_ref13","isNavigateInProgress","realHistory","_serialize$read3","_realHistory$location","_realHistory$location2","realQuery","_ref15","qs","activeRoutes","isFirstCheckPassed","_params$route$$isOpen","_params$route","_params$clock","$source","cleanupStrategy","cleanup","queryUpdatedFromHistory","currentQuery","nextQuery","key","$queryParam","_query$k","defaultState","options"],"mappings":"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"}