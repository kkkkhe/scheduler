{"version":3,"file":"atomic-router.umd.js","sources":["../src/methods/create-route.ts","../src/utils/equals.ts","../node_modules/.pnpm/path-to-regexp@6.2.1/node_modules/path-to-regexp/dist.es2015/index.js","../src/utils/build-path.ts","../src/utils/history-effects.ts","../src/utils/logic.ts","../src/methods/redirect.ts","../src/types.ts","../src/methods/create-router-controls.ts","../src/methods/is-route.ts","../src/methods/new-create-history-router.ts","../src/methods/query-sync.ts","../src/methods/chain-route.ts","../src/utils/remap-route-objects.ts"],"sourcesContent":["import {\n  attach,\n  createEffect,\n  createEvent,\n  createStore,\n  split,\n  Store,\n} from 'effector';\nimport {\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n  RouteInstance,\n  NavigateParams,\n  Kind,\n  EmptyObject,\n} from '../types';\n\ntype CreateRouteParams = {\n  filter?: Store<boolean>;\n};\n\nexport function createRoute<Params extends RouteParams = {}>(\n  params: CreateRouteParams = {}\n): RouteInstance<Params> {\n  const navigateFx = createEffect<\n    NavigateParams<Params>,\n    NavigateParams<Params>\n  >(({ params, query, replace = false }) => ({\n    params: params || {},\n    query: query || {},\n    replace,\n  }));\n\n  const openFx = attach({\n    effect: navigateFx,\n    mapParams: (params: Params extends EmptyObject ? void : Params) => ({\n      params: (params || {}) as Params,\n      query: {} as RouteQuery,\n    }),\n  });\n\n  const $isOpened = createStore<boolean>(false);\n  const $params = createStore<Params>({} as Params);\n  const $query = createStore<RouteQuery>({});\n\n  const opened = createEvent<RouteParamsAndQuery<Params>>();\n  const updated = createEvent<RouteParamsAndQuery<Params>>();\n  const closed = createEvent<void>();\n\n  $isOpened.on(opened, () => true).on(closed, () => false);\n\n  $params\n    .on(opened, (_, { params }) => params)\n    .on(updated, (_, { params }) => params);\n\n  $query\n    .on(opened, (_, { query }) => query)\n    .on(updated, (_, { query }) => query);\n\n  split({\n    source: navigateFx.doneData,\n    match: $isOpened.map((isOpened) => (isOpened ? 'updated' : 'opened')),\n    cases: {\n      opened,\n      updated,\n    },\n  });\n\n  // if (params.filter) {\n  //   const filter = params.filter;\n  //   split({\n  //     // @ts-expect-error\n  //     source: sample({ clock: filter }),\n  //     // @ts-expect-error\n  //     match: (filter) => (filter ? 'true' : 'false'),\n  //     cases: {\n  //       true: opened,\n  //       false: closed,\n  //     },\n  //   });\n  // }\n\n  const instance: RouteInstance<Params> = {\n    $isOpened,\n    $params,\n    $query,\n    opened,\n    updated,\n    closed,\n    navigate: navigateFx,\n    open: openFx,\n    kind: Kind.ROUTE,\n    // @ts-expect-error Internal stuff\n    settings: {\n      derived: Boolean(params.filter),\n    },\n  };\n\n  return instance;\n}\n","export function paramsEqual(a: Record<string, any>, b: Record<string, any>) {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const k in a) {\n    // NOTE: Parsed URI always returns string parameters\n    // so we force string comparison here\n    // in order to avoid extra updates\n    // whenever user passes numeric params\n    if (`${a[k]}` !== `${b[k]}`) {\n      return false;\n    }\n  }\n  return true;\n}\n","/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a;\n    var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || defaultPattern,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n                    }\n                    else {\n                        route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                    }\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map","import { match, compile } from 'path-to-regexp';\n\nimport {\n  RouteParams,\n  PathCreator,\n  RouteQuery,\n  ParamsSerializer,\n} from '../types';\n\n// NOTE: If path is URL - provide it as is\n// Otherwise - extract pathname and hash\nconst getComparablePath = (path: string) => {\n  if (path.match(/^[a-z0-9]+\\:\\/\\//i)) {\n    return path;\n  }\n  const url = new URL(`http://_${path}`);\n  return [url.pathname, url.hash].join('');\n};\n\n// NOTE: path-to-regexp treats \":\" in \"https://\" as param start\n// So we escape it\nfunction normalizePathCreator(pathCreator: string) {\n  return pathCreator.replace('://', '\\\\://');\n}\n\ntype BuildPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  params: Params;\n  query: RouteQuery;\n  serialize?: ParamsSerializer;\n};\nexport function buildPath<Params extends RouteParams>({\n  pathCreator,\n  params,\n  query,\n  serialize,\n}: BuildPathParams<Params>) {\n  const pathname = compile(pathCreator)(params);\n  const serializedParams =\n    serialize?.write(query) ?? new URLSearchParams(query);\n  const qs = Object.keys(query).length ? `?${serializedParams}` : '';\n  const url = `${pathname}${qs}`;\n  return url;\n}\n\ntype MatchPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  actualPath: string;\n};\nexport function matchPath<Params extends RouteParams>({\n  pathCreator,\n  actualPath,\n}: MatchPathParams<Params>) {\n  const matches = match(normalizePathCreator(pathCreator))(\n    getComparablePath(actualPath)\n  );\n  if (matches) {\n    return { matches: true, params: matches.params } as const;\n  }\n  return { matches: false } as const;\n}\n","import { History } from 'history';\nimport { createEffect } from 'effector';\n\nimport { HistoryBackForwardParams, HistoryPushParams } from '../types';\n\nfunction assertHistory(history: History) {\n  if (!history) {\n    throw new Error('[Routing] No history provided');\n  }\n}\n\nexport const historyPushFx = createEffect((params: HistoryPushParams) => {\n  assertHistory(params.history);\n  params.history[params.method](params.path, {});\n  return params;\n});\n\nexport const historyBackFx = createEffect(\n  (history: HistoryBackForwardParams) => {\n    assertHistory(history);\n    history.back();\n    return history;\n  }\n);\n\nexport const historyForwardFx = createEffect(\n  (history: HistoryBackForwardParams) => {\n    assertHistory(history);\n    history.forward();\n    return history;\n  }\n);\n","import { Store } from 'effector';\n\nexport function not<T>(source: Store<T>): Store<boolean> {\n  return source.map((value) => !value);\n}\n","import {\n  Clock,\n  createEvent,\n  createStore,\n  Event,\n  is,\n  sample,\n  Store,\n} from 'effector';\nimport { EmptyObject, RouteInstance, RouteParams, RouteQuery } from '../types';\n\ntype RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject\n  ? {\n      clock?: Clock<T>;\n      route: RouteInstance<Params>;\n      query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n      replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n    }\n  :\n      | {\n          clock?: Clock<T>;\n          route: RouteInstance<Params>;\n          params: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        }\n      | {\n          clock?: Clock<{\n            params: Params;\n            query?: RouteQuery;\n            replace?: boolean;\n          }>;\n          route: RouteInstance<Params>;\n          params?: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        };\n\n/** Opens passed `route` upon `clock` trigger */\nexport function redirect<T, Params extends RouteParams>(\n  options: RedirectParams<T, Params>\n) {\n  const clock = options.clock\n    ? sample({ clock: options.clock as Event<T> })\n    : createEvent<T>();\n\n  let params = toStore(options.params || {});\n  let query = toStore(options.query || {});\n  // @ts-expect-error\n  let replace = toStore(options.replace || false);\n\n  sample({\n    clock: clock,\n    source: { params, query, replace },\n    fn: ({ params, query, replace }, clock) => ({\n      params: typeof params === 'function' ? params(clock) : params,\n      query: typeof query === 'function' ? query(clock) : query,\n      replace: typeof replace === 'function' ? replace(clock) : replace,\n    }),\n    target: options.route.navigate,\n  });\n  return clock;\n}\n\nfunction toStore<T>(payload: T | Store<T>): Store<T> {\n  return is.store(payload) ? payload : createStore(payload as T);\n}\n","import { History } from 'history';\nimport { Effect, Event, Store } from 'effector';\n\nexport type RouteParams = Record<string, any>;\n\nexport type RouteQuery = Record<string, any>;\n\nexport type RouteParamsAndQuery<Params extends RouteParams> = {\n  params: Params;\n  query: RouteQuery;\n};\n\nexport interface NavigateParams<Params extends RouteParams>\n  extends RouteParamsAndQuery<Params> {\n  replace?: boolean;\n}\n\nexport type RouteInstance<Params extends RouteParams> = {\n  $isOpened: Store<boolean>;\n  $params: Store<Params>;\n  $query: Store<RouteQuery>;\n  opened: Event<RouteParamsAndQuery<Params>>;\n  updated: Event<RouteParamsAndQuery<Params>>;\n  closed: Event<void>;\n  navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;\n  open: Effect<\n    Params extends EmptyObject ? void : Params,\n    RouteParamsAndQuery<Params>\n  >;\n  kind: typeof Kind.ROUTE;\n};\n\nexport type RouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  path: string;\n};\n\nexport type UnmappedRouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params> | RouteInstance<Params>[];\n  path: string;\n};\n\nexport type HistoryPushParams = {\n  history: History;\n  path: string;\n  params: RouteParams;\n  query: RouteQuery;\n  method: 'replace' | 'push';\n};\n\nexport type HistoryBackForwardParams = History;\n\nexport type ParamsSerializer = {\n  write: (params: RouteParams) => string;\n  read: (query: string) => RouteParams;\n};\n\n// @ts-expect-error\nexport type PathCreator<Params extends RouteParams> = string;\n\nexport const Kind = {\n  ROUTE: Symbol(),\n};\n\nexport type EmptyObject = { [key in string]: never };\n","import { createEvent, createStore } from 'effector';\n\nimport { RouteQuery } from '../types';\nimport { paramsEqual } from '../utils/equals';\n\nexport const createRouterControls = () => {\n  return {\n    $query: createStore<RouteQuery>(\n      {},\n      {\n        updateFilter: (update, current) => !paramsEqual(current, update),\n      }\n    ),\n    back: createEvent(),\n    forward: createEvent(),\n  };\n};\n","import { Kind, RouteInstance } from '../types';\n\n/** Detects whether passed value is a `RouteInstance<any>` or not */\nexport const isRoute = (\n  route: RouteInstance<any> | unknown\n): route is RouteInstance<any> => {\n  return (\n    typeof route === 'object' &&\n    route !== null &&\n    'kind' in route &&\n    // @ts-expect-error\n    route.kind === Kind.ROUTE\n  );\n};\n","import { History } from 'history';\nimport { attach, createEvent, createStore, sample, scopeBind } from 'effector';\nimport { createRouterControls } from './create-router-controls';\nimport {\n  HistoryPushParams,\n  ParamsSerializer,\n  RouteInstance,\n  RouteObject,\n  RouteParams,\n  RouteQuery,\n  UnmappedRouteObject,\n} from '../types';\nimport { remapRouteObjects } from '../utils/remap-route-objects';\nimport { paramsEqual } from '../utils/equals';\nimport { buildPath, matchPath } from '../utils/build-path';\nimport { isRoute } from './is-route';\nimport {\n  historyBackFx,\n  historyForwardFx,\n  historyPushFx,\n} from '../utils/history-effects';\nimport { not } from '../utils/logic';\n\nexport function createHistoryRouter({\n  base,\n  routes,\n  notFoundRoute,\n  hydrate,\n  serialize,\n  controls = createRouterControls(),\n}: {\n  base?: string;\n  routes: UnmappedRouteObject<any>[];\n  notFoundRoute?: RouteInstance<any>;\n  serialize?: ParamsSerializer;\n  hydrate?: boolean;\n  controls?: ReturnType<typeof createRouterControls>;\n}) {\n  const remappedRoutes = remapRouteObjects(routes, base);\n\n  const setHistory = createEvent<History>();\n  const navigateFromRouteTriggered = createEvent<{\n    route: RouteObject<any>;\n    params: RouteParams;\n    query: RouteQuery;\n    replace: boolean;\n  }>();\n  const historyUpdated = createEvent();\n  const recalculateTriggered = createEvent<{\n    path: string;\n    query: RouteQuery;\n    hash: string;\n  }>();\n  const recalculated = createEvent<{\n    path: string;\n    query: RouteQuery;\n    matching: RecalculationResult<any>[];\n    mismatching: RecalculationResult<any>[];\n  }>();\n  const routesMatched = createEvent<RecalculationResult<any>[]>();\n  const routesMismatched = createEvent<RecalculationResult<any>[]>();\n  const routeNotFound = createEvent();\n  const initialized = createEvent<{\n    activeRoutes: RouteInstance<any>[];\n    path: string;\n    query: RouteQuery;\n  }>();\n\n  const $path = createStore('');\n  const $query = createStore<RouteQuery>(\n    {},\n    {\n      name: 'historyRouter.$query',\n      updateFilter: (newQuery, oldQuery) => !paramsEqual(newQuery, oldQuery),\n    }\n  );\n  const $activeRoutes = createStore<RouteInstance<any>[]>([], {\n    serialize: 'ignore',\n  });\n  // @ts-expect-error\n  const $history = createStore<History>(null, {\n    serialize: 'ignore',\n  });\n  const $isFirstCheckPassed = createStore(false);\n  const $isRouteNavigateInProgress = createStore(false);\n\n  const pushFx = attach({\n    source: $history,\n    effect(history, params: Omit<HistoryPushParams, 'history'>) {\n      return historyPushFx({\n        history,\n        ...params,\n      });\n    },\n  });\n\n  const subscribeHistoryFx = attach({\n    source: $history,\n    effect(history) {\n      let scopedHistoryUpdated = historyUpdated;\n      try {\n        // @ts-expect-error\n        scopedHistoryUpdated = scopeBind(historyUpdated);\n      } catch (err) {}\n      history.listen(() => {\n        scopedHistoryUpdated();\n      });\n      return true;\n    },\n  });\n\n  const historyUpdatedParsed = sample({\n    clock: hydrate\n      ? [historyUpdated]\n      : [historyUpdated, subscribeHistoryFx.done],\n    source: $history,\n    filter: Boolean,\n    fn: (history) => ({\n      path: history.location.pathname,\n      query:\n        serialize?.read(history.location.search) ??\n        Object.fromEntries(new URLSearchParams(history.location.search)),\n    }),\n  });\n\n  // If `hydrate` flag is set,\n  // don't trigger recheck on history init\n  const historyUpdateTriggered = sample({\n    clock: historyUpdatedParsed,\n    source: {\n      path: $path,\n      query: $query,\n    },\n    filter: ({ path: savedPath, query: savedQuery }, history) =>\n      history.path !== savedPath || !paramsEqual(history.query, savedQuery),\n    fn: (_, history) => history,\n  });\n\n  /// History subscription\n  $history.on(setHistory, (_, history) => history);\n\n  sample({\n    clock: $history,\n    target: subscribeHistoryFx,\n  });\n\n  sample({\n    clock: historyUpdateTriggered,\n    source: $history,\n    filter: Boolean,\n    fn(history) {\n      const path = history?.location.pathname;\n      const hash = history?.location.hash;\n      const query: RouteQuery =\n        serialize?.read(history?.location.search) ??\n        Object.fromEntries(new URLSearchParams(history?.location.search));\n      return { path, query, hash };\n    },\n    target: recalculateTriggered,\n  });\n\n  /// Routes updates handling\n  for (const routeObj of remappedRoutes) {\n    const currentRouteMatched = routesMatched.filterMap(\n      containsCurrentRoute(routeObj)\n    );\n    const currentRouteMismatched = routesMismatched.filterMap(\n      containsCurrentRoute(routeObj)\n    );\n    const routeStateChangeRequested = {\n      opened: sample({\n        clock: currentRouteMatched,\n        filter: not(routeObj.route.$isOpened),\n      }),\n      updated: sample({\n        clock: currentRouteMatched,\n        filter: routeObj.route.$isOpened,\n      }),\n      closed: sample({\n        clock: currentRouteMismatched,\n        filter: routeObj.route.$isOpened,\n      }),\n    };\n\n    // Trigger .updated() for the routes marked as \"matched\" but already opened\n    sample({\n      clock: routeStateChangeRequested.updated,\n      source: [routeObj.route.$params, routeObj.route.$query],\n      // Skip .updated() calls if params & query are the same\n      filter: ([params, query], next) =>\n        !paramsEqual(params, next.params) || !paramsEqual(query, next.query),\n      fn: (_, paramsAndQuery) => paramsAndQuery,\n      target: routeObj.route.updated,\n    });\n\n    // Trigger .opened() for the routes marked as \"matched\" but not opened yet\n    sample({\n      clock: routeStateChangeRequested.opened,\n      // TODO: Scratch this?\n      filter: not($isRouteNavigateInProgress),\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .closed() for the routes marked as \"mismatched\" but opened\n    sample({\n      clock: routeStateChangeRequested.closed,\n      target: routeObj.route.closed,\n    });\n  }\n\n  /// Handling route.navigateFx navigation\n  for (const routeObj of remappedRoutes) {\n    // Run \"Handling route.navigateFx navigation\" step\n    sample({\n      clock: routeObj.route.navigate.doneData,\n      fn: ({ params, query, replace }) => ({\n        route: routeObj,\n        params,\n        query,\n        replace: replace ?? false,\n      }),\n      target: navigateFromRouteTriggered,\n    });\n  }\n\n  $isRouteNavigateInProgress.on(navigateFromRouteTriggered, () => true);\n\n  sample({\n    clock: navigateFromRouteTriggered,\n    fn({ route, params, query, replace }) {\n      const path = buildPath({\n        pathCreator: route.path,\n        params,\n        query,\n        serialize,\n      });\n      const method: 'replace' | 'push' = replace ? 'replace' : 'push';\n      return {\n        path,\n        params,\n        query,\n        method,\n      };\n    },\n    target: pushFx,\n  });\n\n  $isRouteNavigateInProgress.reset([routesMatched, routesMismatched]);\n\n  /// Recalculation\n  // Triggered on every history change + once when history instance is set\n  sample({\n    clock: recalculateTriggered,\n    fn({ path, query, hash }) {\n      const matchingRoutes = [] as RecalculationResult<any>[];\n      const mismatchingRoutes = [] as RecalculationResult<any>[];\n\n      for (const route of remappedRoutes) {\n        // NOTE: Use hash string as well if route.path contains #\n        const actualPath = route.path.includes('#')\n          ? `${path}${hash}`\n          : `${path}`;\n        const { matches, params } = matchPath({\n          pathCreator: route.path,\n          actualPath,\n        });\n\n        const suitableRoutes = matches ? matchingRoutes : mismatchingRoutes;\n        suitableRoutes.push({\n          routeObj: route,\n          params,\n          query,\n        });\n      }\n\n      // Checking for routes we need to close\n      // Remove all that are marked to be opened\n      mismatchingRoutes.forEach((mismatchedRoute, mismatchedIndex) => {\n        const mismatchedRouteExistsInMatchedList = matchingRoutes.some(\n          (matchedRoute) =>\n            matchedRoute.routeObj.route === mismatchedRoute.routeObj.route\n        );\n        if (mismatchedRouteExistsInMatchedList) {\n          mismatchingRoutes.splice(mismatchedIndex, 1);\n        }\n      });\n\n      return {\n        matching: matchingRoutes,\n        mismatching: mismatchingRoutes.filter(Boolean),\n        path,\n        query,\n      };\n    },\n    target: recalculated,\n  });\n\n  $path.on(historyUpdateTriggered, (_, { path }) => path);\n\n  $query.on(historyUpdateTriggered, (_, { query }) => query);\n\n  const matchingRecalculated = recalculated.map(({ matching }) => matching);\n\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length > 0,\n    target: routesMatched,\n  });\n\n  sample({\n    clock: recalculated.map(({ mismatching }) => mismatching),\n    filter: (routes) => routes.length > 0,\n    target: routesMismatched,\n  });\n\n  $activeRoutes.on(recalculated, (_, { matching }) =>\n    matching.map((recheckResult) => recheckResult.routeObj.route)\n  );\n\n  /// Handling 404\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length === 0,\n    target: routeNotFound,\n  });\n\n  if (isRoute(notFoundRoute)) {\n    sample({\n      clock: routeNotFound,\n      source: $query,\n      filter: notFoundRoute.$isOpened,\n      fn: (query) => ({ query, params: {} }),\n      target: notFoundRoute.updated,\n    });\n\n    sample({\n      clock: routeNotFound,\n      source: { query: $query, isOpened: notFoundRoute.$isOpened },\n      filter: ({ isOpened }) => !isOpened,\n      fn: ({ query }) => ({ query, params: {} }),\n      target: notFoundRoute.opened,\n    });\n\n    sample({\n      clock: matchingRecalculated,\n      source: notFoundRoute.$isOpened,\n      filter: (isOpened, matching) => isOpened && matching.length > 0,\n      target: notFoundRoute.closed,\n    });\n  }\n\n  /// Back/forward navigation\n  sample({\n    clock: controls.back,\n    source: $history,\n    target: historyBackFx,\n  });\n\n  sample({\n    clock: controls.forward,\n    source: $history,\n    target: historyForwardFx,\n  });\n\n  /// Query syncing\n  sample({\n    clock: $query,\n    source: { controlsQuery: controls.$query, localQuery: $query },\n    filter: ({ controlsQuery, localQuery }) =>\n      !paramsEqual(controlsQuery, localQuery),\n    fn: ({ localQuery }) => localQuery,\n    target: controls.$query,\n  });\n\n  sample({\n    clock: controls.$query,\n    source: {\n      path: $path,\n      localQuery: $query,\n      isNavigateInProgress: $isRouteNavigateInProgress,\n      realHistory: $history,\n    },\n    filter: ({ localQuery, isNavigateInProgress, realHistory }, query) => {\n      const realQuery =\n        serialize?.read(realHistory?.location.search ?? '') ??\n        Object.fromEntries(\n          new URLSearchParams(realHistory?.location.search ?? '')\n        );\n      return (\n        isNavigateInProgress ||\n        !paramsEqual(query, realQuery) ||\n        !paramsEqual(localQuery, query)\n      );\n    },\n    fn({ path }, query) {\n      const qs = serialize?.write(query) ?? new URLSearchParams(query);\n      return {\n        path: `${path}${qs ? `?${qs}` : ''}`,\n        params: {},\n        query: query,\n        method: 'push' as const,\n      };\n    },\n    target: pushFx,\n  });\n\n  /// Initialization\n  sample({\n    clock: recalculated,\n    source: {\n      activeRoutes: $activeRoutes,\n      path: $path,\n      query: $query,\n    },\n    filter: $isFirstCheckPassed.map(\n      (isFirstCheckPassed) => !isFirstCheckPassed\n    ),\n    target: initialized,\n  });\n\n  $isFirstCheckPassed.on(initialized, () => true).reset($history);\n\n  return {\n    $path,\n    $activeRoutes,\n    $history,\n    setHistory,\n    $query: $query,\n    back: controls.back,\n    forward: controls.forward,\n    push: pushFx,\n    routes: remappedRoutes,\n    initialized,\n    routeNotFound,\n  };\n}\n\ntype RecalculationResult<Params extends RouteParams> = {\n  routeObj: RouteObject<Params>;\n  params: Params;\n  query: RouteQuery;\n};\n\nconst containsCurrentRoute =\n  (routeObj: RouteObject<any>) =>\n  (recheckResults: RecalculationResult<any>[]) => {\n    const recheck = recheckResults.find(\n      (recheckResult) => recheckResult.routeObj.route === routeObj.route\n    );\n    if (!recheck) {\n      return;\n    }\n    return {\n      params: recheck.params,\n      query: recheck.query,\n    };\n  };\n","import { Clock, combine, createStore, sample, Store, Unit } from 'effector';\n\nimport { RouteInstance, RouteQuery } from '../types';\nimport { createRouterControls } from './create-router-controls';\n\ntype QueryCleanupStrategy = {\n  irrelevant: boolean;\n  empty: boolean;\n  preserve: string[];\n};\n\ntype QuerySyncParams<T extends Record<string, Store<any>>> = {\n  source: T;\n  clock?: Clock<any>;\n  controls: ReturnType<typeof createRouterControls>;\n  route?: RouteInstance<any>;\n  cleanup?: boolean | Partial<QueryCleanupStrategy>;\n};\n\nexport function querySync<T extends Record<string, Store<any>>>(\n  params: QuerySyncParams<T>\n) {\n  const $isOpened = params.route?.$isOpened ?? createStore(true);\n  const $source = combine(params.source);\n  const clock = (params.clock ?? $source) as Unit<any>;\n  const cleanupStrategy = !('cleanup' in params)\n    ? cleanupStrategies.default\n    : typeof params.cleanup === 'boolean'\n    ? cleanupStrategies[params.cleanup ? 'all' : 'none']\n    : { ...cleanupStrategies.default, ...params.cleanup! };\n\n  const queryUpdatedFromHistory = sample({\n    clock: params.controls.$query,\n    filter: $isOpened,\n  });\n\n  sample({\n    clock,\n    source: combine([$source, params.controls.$query]),\n    filter: $isOpened,\n    fn: ([source, currentQuery]) => {\n      let nextQuery: RouteQuery = {};\n      if (cleanupStrategy.irrelevant) {\n        for (const key of cleanupStrategy.preserve) {\n          if (key in currentQuery) {\n            nextQuery[key] = currentQuery[key];\n          }\n        }\n      } else {\n        nextQuery = { ...currentQuery };\n      }\n      for (const key in source) {\n        nextQuery[key] = source[key];\n      }\n      if (cleanupStrategy.empty) {\n        for (const key in source) {\n          if (!cleanupStrategy.preserve.includes(key) && !nextQuery[key]) {\n            delete nextQuery[key];\n          }\n        }\n      }\n      return nextQuery as RouteQuery;\n    },\n    target: params.controls.$query,\n  });\n\n  for (const k in params.source) {\n    const $queryParam = params.source[k as keyof typeof params.source];\n    $queryParam.on(queryUpdatedFromHistory, (_, query) => {\n      return query[k] ?? $queryParam.defaultState;\n    });\n  }\n}\n\nconst cleanupStrategies = {\n  all: {\n    irrelevant: true,\n    empty: true,\n    preserve: [],\n  },\n  default: {\n    irrelevant: false,\n    empty: true,\n    preserve: [],\n  },\n  none: {\n    irrelevant: false,\n    empty: false,\n    preserve: [],\n  },\n};\n","import {\n  is,\n  guard,\n  merge,\n  sample,\n  combine,\n  createStore,\n  Unit,\n  Clock,\n  Effect,\n  StoreValue,\n  createEvent,\n  NoInfer,\n  EffectParams,\n  attach,\n} from 'effector';\n\nimport { createRoute } from './create-route';\nimport {\n  RouteInstance,\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n} from '../types';\n\nimport { isRoute } from './is-route';\n\ntype ChainRouteParamsInternalAttach<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: {\n    effect: FX;\n    mapParams: ({\n      params,\n      query,\n    }: {\n      params: Params;\n      query: RouteQuery;\n    }) => NoInfer<EffectParams<FX>>;\n  };\n  openOn?: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsWithEffect<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;\n};\n\ntype ChainRouteParamsAdvanced<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsNormalized<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn: Clock<any>;\n};\n\ntype chainRouteParams<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n> =\n  | RouteInstance<Params>\n  | ChainRouteParamsWithEffect<Params>\n  | ChainRouteParamsAdvanced<Params>\n  | ChainRouteParamsInternalAttach<Params, FX>;\n\nfunction normalizeChainRouteParams<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(params: chainRouteParams<Params, FX>): ChainRouteParamsNormalized<Params> {\n  const resultParams: ChainRouteParamsNormalized<Params> =\n    {} as ChainRouteParamsNormalized<Params>;\n  if (isRoute(params)) {\n    Object.assign(resultParams, {\n      route: params,\n      chainedRoute: createRoute<Params>(),\n      beforeOpen: createEvent(),\n      openOn: merge([params.opened, params.closed]),\n      cancelOn: merge([createEvent()]),\n    });\n    return resultParams;\n  }\n  const effectParams = params as ChainRouteParamsWithEffect<Params>;\n  Object.assign(resultParams, {\n    route: effectParams.route,\n    chainedRoute: effectParams.chainedRoute || createRoute<Params>(),\n    beforeOpen: is.unit(effectParams.beforeOpen)\n      ? effectParams.beforeOpen\n      : attach(effectParams.beforeOpen),\n  });\n  if (is.effect(resultParams.beforeOpen)) {\n    Object.assign(resultParams, {\n      openOn:\n        // @ts-expect-error\n        effectParams.openOn || resultParams.beforeOpen.doneData,\n      cancelOn:\n        // @ts-expect-error\n        effectParams.cancelOn || resultParams.beforeOpen.failData,\n    });\n    return resultParams;\n  }\n  const advancedParams = params as ChainRouteParamsAdvanced<Params>;\n  Object.assign(resultParams, {\n    openOn: sample({ clock: advancedParams.openOn as Unit<any> }),\n    cancelOn: sample({\n      clock: (advancedParams.cancelOn as Unit<any>) || createEvent(),\n    }),\n  });\n  return resultParams;\n}\n\nfunction chainRoute<Params extends RouteParams>(\n  instance: RouteInstance<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsWithEffect<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsAdvanced<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(config: ChainRouteParamsInternalAttach<Params, FX>): RouteInstance<Params>;\n\n/**\n * Creates chained route\n * @link https://github.com/Kelin2025/atomic-router/issues/10\n * @param {RouteInstance<any>} params.route - Route to listen\n * @param {RouteInstance<any>} [params.chainedRoute]  - Route to be created\n * @param {Clock<any>} params.beforeOpen - Will be triggered when `params.route` open\n * @param {Clock<any>} params.openOn - Will open `chainedRoute` if `params.route` is still opened\n * @param {Clock<any>} params.cancelOn - Cancels chain\n * @returns {RouteInstance<any>} `chainedRoute`\n */\nfunction chainRoute<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(params: chainRouteParams<Params, FX>) {\n  const { route, chainedRoute, beforeOpen, openOn, cancelOn } =\n    normalizeChainRouteParams(params);\n  const $params = createStore({} as StoreValue<typeof route['$params']>);\n  const $query = createStore({} as StoreValue<typeof route['$query']>);\n  const $hasSameParams = combine(\n    combine([route.$params, route.$query]),\n    combine([$params, $query]),\n    (current, stored) => {\n      return current[0] === stored[0] && current[1] === stored[1];\n    }\n  );\n  const routeOpened = sample({\n    clock: [route.opened, route.updated],\n  });\n  // 1. Call `beforeOpen` whenever route is opened\n  sample({\n    clock: routeOpened,\n    target: beforeOpen as Unit<RouteParamsAndQuery<any>>,\n  });\n  $params.on(routeOpened, (_prev, { params }) => params);\n  $query.on(routeOpened, (_prev, { query }) => query);\n  // 2. Listen to `openOn` if route is still opened on the same position\n  const chainedRouteResolved = guard({\n    clock: openOn,\n    source: { params: $params, query: $query },\n    filter: $hasSameParams,\n  });\n  sample({\n    clock: chainedRouteResolved,\n    target: chainedRoute.navigate,\n  });\n  // 4. Cancel loading if page closed or `cancelOn` is called\n  // @ts-expect-error\n  const aborted = merge([route.closed, cancelOn]);\n  $params.reset(aborted);\n  $query.reset(aborted);\n  sample({\n    clock: aborted,\n    target: chainedRoute.closed,\n  });\n  return chainedRoute;\n}\n\n// This is written separately to correctly export all type overloads\nexport { chainRoute };\n","import { UnmappedRouteObject, RouteObject } from '../types';\n\nexport function remapRouteObjects(\n  objects: UnmappedRouteObject<any>[],\n  basePath: string = ''\n) {\n  let next: RouteObject<any>[] = [];\n  for (const routeObj of objects) {\n    if (Array.isArray(routeObj.route)) {\n      next.push(...routeObj.route.map((route) => ({ ...routeObj, route })));\n    } else {\n      // @ts-expect-error\n      next.push(routeObj);\n    }\n  }\n  next = next.map((routeObj) => ({\n    ...routeObj,\n    path: `${basePath}${routeObj.path}`,\n  }));\n  const derivedRoutes: RouteObject<any>[] = [];\n  const nonDerivedRoutes: RouteObject<any>[] = [];\n  for (const routeObj of next) {\n    // @ts-expect-error Internals\n    if (routeObj.route.settings.derived) {\n      derivedRoutes.push(routeObj);\n    } else {\n      nonDerivedRoutes.push(routeObj);\n    }\n  }\n  if (derivedRoutes.length) {\n    for (const derivedRoute of derivedRoutes) {\n      console.error(\n        `createHistoryRouter: ${derivedRoute.path} uses derived route. This won't work`\n      );\n    }\n  }\n  return nonDerivedRoutes;\n}\n"],"names":["createRoute","params","navigateFx","createEffect","_ref","_ref$replace","replace","query","name","sid","openFx","attach","and","effect","mapParams","or","$isOpened","createStore","$params","$query","opened","createEvent","updated","closed","on","_","_ref2","_ref3","_ref4","_ref5","split","source","doneData","match","map","isOpened","cases","navigate","open","kind","Kind","ROUTE","settings","derived","Boolean","filter","paramsEqual","a","b","Object","keys","length","k","parse","str","options","tokens","i","char","push","type","index","value","count","pattern","j","TypeError","concat","code","charCodeAt","lexer","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","consumeText","indexOf","prefix","suffix","modifier","name_1","pattern_1","re","decode","x","pathname","m","exec","create","_loop_1","regexpToFunction","pathToRegexp","flags","sensitive","RegExp","groupsRegex","execResult","regexpToRegexp","Array","isArray","paths","parts","join","arrayToRegexp","strict","_b","start","_c","end","_d","encode","_e","_f","endsWith","endsWithRe","delimiterRe","route","_i","tokens_1","token","mod","endToken","isEndDelimited","tokensToRegexp","stringToRegexp","buildPath","_serialize$write","serialize","reFlags","validate","matches","data","optional","repeat","segment","test","typeOfMessage","String","tokensToFunction","compile","pathCreator","serializedParams","write","URLSearchParams","matchPath","actualPath","normalizePathCreator","url","URL","hash","getComparablePath","assertHistory","history","Error","not","toStore","payload","is","store","Symbol","createRouterControls","updateFilter","update","current","back","forward","isRoute","historyPushFx","method","historyBackFx","historyForwardFx","containsCurrentRoute","routeObj","recheckResults","recheck","find","recheckResult","cleanupStrategies","all","irrelevant","empty","preserve","default","none","normalizeChainRouteParams","resultParams","_withFactory","fn","assign","chainedRoute","beforeOpen","openOn","merge","cancelOn","effectParams","unit","failData","advancedParams","sample","clock","$hasSameParams","combine","stored","routeOpened","target","_prev","chainedRouteResolved","guard","aborted","reset","base","routes","notFoundRoute","hydrate","_ref$controls","controls","remappedRoutes","objects","basePath","_step","next","_loop","_next","_objectSpread","_iterator","_createForOfIteratorHelperLoose","done","_step2","derivedRoutes","nonDerivedRoutes","_iterator2","_step3","_iterator3","console","error","derivedRoute","remapRouteObjects","setHistory","navigateFromRouteTriggered","historyUpdated","recalculateTriggered","recalculated","routesMatched","routesMismatched","routeNotFound","initialized","$path","newQuery","oldQuery","$activeRoutes","$history","$isFirstCheckPassed","$isRouteNavigateInProgress","pushFx","subscribeHistoryFx","scopedHistoryUpdated","scopeBind","err","listen","historyUpdatedParsed","_serialize$read","location","read","search","fromEntries","historyUpdateTriggered","_serialize$read2","currentRouteMatched","filterMap","currentRouteMismatched","routeStateChangeRequested","_ref16","paramsAndQuery","_ref17","matchingRoutes","mismatchingRoutes","includes","_matchPath","forEach","mismatchedRoute","mismatchedIndex","some","matchedRoute","splice","matching","mismatching","_ref6","matchingRecalculated","_ref7","_ref8","_ref9","_ref10","_ref11","controlsQuery","localQuery","_ref12","_ref13","isNavigateInProgress","realHistory","_serialize$read3","_realHistory$location","_realHistory$location2","realQuery","_ref15","qs","activeRoutes","isFirstCheckPassed","_params$route$$isOpen","_params$route","_params$clock","$source","cleanupStrategy","cleanup","queryUpdatedFromHistory","currentQuery","nextQuery","$queryParam","_query$k","defaultState"],"mappings":"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"}