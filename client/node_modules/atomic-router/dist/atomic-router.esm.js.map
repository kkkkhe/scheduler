{"version":3,"file":"atomic-router.esm.js","sources":["../src/methods/create-route.ts","../src/utils/equals.ts","../src/utils/build-path.ts","../src/utils/history-effects.ts","../src/utils/logic.ts","../src/methods/new-create-history-router.ts","../src/utils/remap-route-objects.ts","../src/methods/redirect.ts","../src/methods/chain-route.ts","../src/methods/query-sync.ts","../src/types.ts","../src/methods/create-router-controls.ts","../src/methods/is-route.ts"],"sourcesContent":["import {\n  attach,\n  createEffect,\n  createEvent,\n  createStore,\n  split,\n  Store,\n} from 'effector';\nimport {\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n  RouteInstance,\n  NavigateParams,\n  Kind,\n  EmptyObject,\n} from '../types';\n\ntype CreateRouteParams = {\n  filter?: Store<boolean>;\n};\n\nexport function createRoute<Params extends RouteParams = {}>(\n  params: CreateRouteParams = {}\n): RouteInstance<Params> {\n  const navigateFx = createEffect<\n    NavigateParams<Params>,\n    NavigateParams<Params>\n  >(({ params, query, replace = false }) => ({\n    params: params || {},\n    query: query || {},\n    replace,\n  }));\n\n  const openFx = attach({\n    effect: navigateFx,\n    mapParams: (params: Params extends EmptyObject ? void : Params) => ({\n      params: (params || {}) as Params,\n      query: {} as RouteQuery,\n    }),\n  });\n\n  const $isOpened = createStore<boolean>(false);\n  const $params = createStore<Params>({} as Params);\n  const $query = createStore<RouteQuery>({});\n\n  const opened = createEvent<RouteParamsAndQuery<Params>>();\n  const updated = createEvent<RouteParamsAndQuery<Params>>();\n  const closed = createEvent<void>();\n\n  $isOpened.on(opened, () => true).on(closed, () => false);\n\n  $params\n    .on(opened, (_, { params }) => params)\n    .on(updated, (_, { params }) => params);\n\n  $query\n    .on(opened, (_, { query }) => query)\n    .on(updated, (_, { query }) => query);\n\n  split({\n    source: navigateFx.doneData,\n    match: $isOpened.map((isOpened) => (isOpened ? 'updated' : 'opened')),\n    cases: {\n      opened,\n      updated,\n    },\n  });\n\n  // if (params.filter) {\n  //   const filter = params.filter;\n  //   split({\n  //     // @ts-expect-error\n  //     source: sample({ clock: filter }),\n  //     // @ts-expect-error\n  //     match: (filter) => (filter ? 'true' : 'false'),\n  //     cases: {\n  //       true: opened,\n  //       false: closed,\n  //     },\n  //   });\n  // }\n\n  const instance: RouteInstance<Params> = {\n    $isOpened,\n    $params,\n    $query,\n    opened,\n    updated,\n    closed,\n    navigate: navigateFx,\n    open: openFx,\n    kind: Kind.ROUTE,\n    // @ts-expect-error Internal stuff\n    settings: {\n      derived: Boolean(params.filter),\n    },\n  };\n\n  return instance;\n}\n","export function paramsEqual(a: Record<string, any>, b: Record<string, any>) {\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const k in a) {\n    // NOTE: Parsed URI always returns string parameters\n    // so we force string comparison here\n    // in order to avoid extra updates\n    // whenever user passes numeric params\n    if (`${a[k]}` !== `${b[k]}`) {\n      return false;\n    }\n  }\n  return true;\n}\n","import { match, compile } from 'path-to-regexp';\n\nimport {\n  RouteParams,\n  PathCreator,\n  RouteQuery,\n  ParamsSerializer,\n} from '../types';\n\n// NOTE: If path is URL - provide it as is\n// Otherwise - extract pathname and hash\nconst getComparablePath = (path: string) => {\n  if (path.match(/^[a-z0-9]+\\:\\/\\//i)) {\n    return path;\n  }\n  const url = new URL(`http://_${path}`);\n  return [url.pathname, url.hash].join('');\n};\n\n// NOTE: path-to-regexp treats \":\" in \"https://\" as param start\n// So we escape it\nfunction normalizePathCreator(pathCreator: string) {\n  return pathCreator.replace('://', '\\\\://');\n}\n\ntype BuildPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  params: Params;\n  query: RouteQuery;\n  serialize?: ParamsSerializer;\n};\nexport function buildPath<Params extends RouteParams>({\n  pathCreator,\n  params,\n  query,\n  serialize,\n}: BuildPathParams<Params>) {\n  const pathname = compile(pathCreator)(params);\n  const serializedParams =\n    serialize?.write(query) ?? new URLSearchParams(query);\n  const qs = Object.keys(query).length ? `?${serializedParams}` : '';\n  const url = `${pathname}${qs}`;\n  return url;\n}\n\ntype MatchPathParams<Params extends RouteParams> = {\n  pathCreator: PathCreator<Params>;\n  actualPath: string;\n};\nexport function matchPath<Params extends RouteParams>({\n  pathCreator,\n  actualPath,\n}: MatchPathParams<Params>) {\n  const matches = match(normalizePathCreator(pathCreator))(\n    getComparablePath(actualPath)\n  );\n  if (matches) {\n    return { matches: true, params: matches.params } as const;\n  }\n  return { matches: false } as const;\n}\n","import { History } from 'history';\nimport { createEffect } from 'effector';\n\nimport { HistoryBackForwardParams, HistoryPushParams } from '../types';\n\nfunction assertHistory(history: History) {\n  if (!history) {\n    throw new Error('[Routing] No history provided');\n  }\n}\n\nexport const historyPushFx = createEffect((params: HistoryPushParams) => {\n  assertHistory(params.history);\n  params.history[params.method](params.path, {});\n  return params;\n});\n\nexport const historyBackFx = createEffect(\n  (history: HistoryBackForwardParams) => {\n    assertHistory(history);\n    history.back();\n    return history;\n  }\n);\n\nexport const historyForwardFx = createEffect(\n  (history: HistoryBackForwardParams) => {\n    assertHistory(history);\n    history.forward();\n    return history;\n  }\n);\n","import { Store } from 'effector';\n\nexport function not<T>(source: Store<T>): Store<boolean> {\n  return source.map((value) => !value);\n}\n","import { History } from 'history';\nimport { attach, createEvent, createStore, sample, scopeBind } from 'effector';\nimport { createRouterControls } from './create-router-controls';\nimport {\n  HistoryPushParams,\n  ParamsSerializer,\n  RouteInstance,\n  RouteObject,\n  RouteParams,\n  RouteQuery,\n  UnmappedRouteObject,\n} from '../types';\nimport { remapRouteObjects } from '../utils/remap-route-objects';\nimport { paramsEqual } from '../utils/equals';\nimport { buildPath, matchPath } from '../utils/build-path';\nimport { isRoute } from './is-route';\nimport {\n  historyBackFx,\n  historyForwardFx,\n  historyPushFx,\n} from '../utils/history-effects';\nimport { not } from '../utils/logic';\n\nexport function createHistoryRouter({\n  base,\n  routes,\n  notFoundRoute,\n  hydrate,\n  serialize,\n  controls = createRouterControls(),\n}: {\n  base?: string;\n  routes: UnmappedRouteObject<any>[];\n  notFoundRoute?: RouteInstance<any>;\n  serialize?: ParamsSerializer;\n  hydrate?: boolean;\n  controls?: ReturnType<typeof createRouterControls>;\n}) {\n  const remappedRoutes = remapRouteObjects(routes, base);\n\n  const setHistory = createEvent<History>();\n  const navigateFromRouteTriggered = createEvent<{\n    route: RouteObject<any>;\n    params: RouteParams;\n    query: RouteQuery;\n    replace: boolean;\n  }>();\n  const historyUpdated = createEvent();\n  const recalculateTriggered = createEvent<{\n    path: string;\n    query: RouteQuery;\n    hash: string;\n  }>();\n  const recalculated = createEvent<{\n    path: string;\n    query: RouteQuery;\n    matching: RecalculationResult<any>[];\n    mismatching: RecalculationResult<any>[];\n  }>();\n  const routesMatched = createEvent<RecalculationResult<any>[]>();\n  const routesMismatched = createEvent<RecalculationResult<any>[]>();\n  const routeNotFound = createEvent();\n  const initialized = createEvent<{\n    activeRoutes: RouteInstance<any>[];\n    path: string;\n    query: RouteQuery;\n  }>();\n\n  const $path = createStore('');\n  const $query = createStore<RouteQuery>(\n    {},\n    {\n      name: 'historyRouter.$query',\n      updateFilter: (newQuery, oldQuery) => !paramsEqual(newQuery, oldQuery),\n    }\n  );\n  const $activeRoutes = createStore<RouteInstance<any>[]>([], {\n    serialize: 'ignore',\n  });\n  // @ts-expect-error\n  const $history = createStore<History>(null, {\n    serialize: 'ignore',\n  });\n  const $isFirstCheckPassed = createStore(false);\n  const $isRouteNavigateInProgress = createStore(false);\n\n  const pushFx = attach({\n    source: $history,\n    effect(history, params: Omit<HistoryPushParams, 'history'>) {\n      return historyPushFx({\n        history,\n        ...params,\n      });\n    },\n  });\n\n  const subscribeHistoryFx = attach({\n    source: $history,\n    effect(history) {\n      let scopedHistoryUpdated = historyUpdated;\n      try {\n        // @ts-expect-error\n        scopedHistoryUpdated = scopeBind(historyUpdated);\n      } catch (err) {}\n      history.listen(() => {\n        scopedHistoryUpdated();\n      });\n      return true;\n    },\n  });\n\n  const historyUpdatedParsed = sample({\n    clock: hydrate\n      ? [historyUpdated]\n      : [historyUpdated, subscribeHistoryFx.done],\n    source: $history,\n    filter: Boolean,\n    fn: (history) => ({\n      path: history.location.pathname,\n      query:\n        serialize?.read(history.location.search) ??\n        Object.fromEntries(new URLSearchParams(history.location.search)),\n    }),\n  });\n\n  // If `hydrate` flag is set,\n  // don't trigger recheck on history init\n  const historyUpdateTriggered = sample({\n    clock: historyUpdatedParsed,\n    source: {\n      path: $path,\n      query: $query,\n    },\n    filter: ({ path: savedPath, query: savedQuery }, history) =>\n      history.path !== savedPath || !paramsEqual(history.query, savedQuery),\n    fn: (_, history) => history,\n  });\n\n  /// History subscription\n  $history.on(setHistory, (_, history) => history);\n\n  sample({\n    clock: $history,\n    target: subscribeHistoryFx,\n  });\n\n  sample({\n    clock: historyUpdateTriggered,\n    source: $history,\n    filter: Boolean,\n    fn(history) {\n      const path = history?.location.pathname;\n      const hash = history?.location.hash;\n      const query: RouteQuery =\n        serialize?.read(history?.location.search) ??\n        Object.fromEntries(new URLSearchParams(history?.location.search));\n      return { path, query, hash };\n    },\n    target: recalculateTriggered,\n  });\n\n  /// Routes updates handling\n  for (const routeObj of remappedRoutes) {\n    const currentRouteMatched = routesMatched.filterMap(\n      containsCurrentRoute(routeObj)\n    );\n    const currentRouteMismatched = routesMismatched.filterMap(\n      containsCurrentRoute(routeObj)\n    );\n    const routeStateChangeRequested = {\n      opened: sample({\n        clock: currentRouteMatched,\n        filter: not(routeObj.route.$isOpened),\n      }),\n      updated: sample({\n        clock: currentRouteMatched,\n        filter: routeObj.route.$isOpened,\n      }),\n      closed: sample({\n        clock: currentRouteMismatched,\n        filter: routeObj.route.$isOpened,\n      }),\n    };\n\n    // Trigger .updated() for the routes marked as \"matched\" but already opened\n    sample({\n      clock: routeStateChangeRequested.updated,\n      source: [routeObj.route.$params, routeObj.route.$query],\n      // Skip .updated() calls if params & query are the same\n      filter: ([params, query], next) =>\n        !paramsEqual(params, next.params) || !paramsEqual(query, next.query),\n      fn: (_, paramsAndQuery) => paramsAndQuery,\n      target: routeObj.route.updated,\n    });\n\n    // Trigger .opened() for the routes marked as \"matched\" but not opened yet\n    sample({\n      clock: routeStateChangeRequested.opened,\n      // TODO: Scratch this?\n      filter: not($isRouteNavigateInProgress),\n      target: routeObj.route.opened,\n    });\n\n    // Trigger .closed() for the routes marked as \"mismatched\" but opened\n    sample({\n      clock: routeStateChangeRequested.closed,\n      target: routeObj.route.closed,\n    });\n  }\n\n  /// Handling route.navigateFx navigation\n  for (const routeObj of remappedRoutes) {\n    // Run \"Handling route.navigateFx navigation\" step\n    sample({\n      clock: routeObj.route.navigate.doneData,\n      fn: ({ params, query, replace }) => ({\n        route: routeObj,\n        params,\n        query,\n        replace: replace ?? false,\n      }),\n      target: navigateFromRouteTriggered,\n    });\n  }\n\n  $isRouteNavigateInProgress.on(navigateFromRouteTriggered, () => true);\n\n  sample({\n    clock: navigateFromRouteTriggered,\n    fn({ route, params, query, replace }) {\n      const path = buildPath({\n        pathCreator: route.path,\n        params,\n        query,\n        serialize,\n      });\n      const method: 'replace' | 'push' = replace ? 'replace' : 'push';\n      return {\n        path,\n        params,\n        query,\n        method,\n      };\n    },\n    target: pushFx,\n  });\n\n  $isRouteNavigateInProgress.reset([routesMatched, routesMismatched]);\n\n  /// Recalculation\n  // Triggered on every history change + once when history instance is set\n  sample({\n    clock: recalculateTriggered,\n    fn({ path, query, hash }) {\n      const matchingRoutes = [] as RecalculationResult<any>[];\n      const mismatchingRoutes = [] as RecalculationResult<any>[];\n\n      for (const route of remappedRoutes) {\n        // NOTE: Use hash string as well if route.path contains #\n        const actualPath = route.path.includes('#')\n          ? `${path}${hash}`\n          : `${path}`;\n        const { matches, params } = matchPath({\n          pathCreator: route.path,\n          actualPath,\n        });\n\n        const suitableRoutes = matches ? matchingRoutes : mismatchingRoutes;\n        suitableRoutes.push({\n          routeObj: route,\n          params,\n          query,\n        });\n      }\n\n      // Checking for routes we need to close\n      // Remove all that are marked to be opened\n      mismatchingRoutes.forEach((mismatchedRoute, mismatchedIndex) => {\n        const mismatchedRouteExistsInMatchedList = matchingRoutes.some(\n          (matchedRoute) =>\n            matchedRoute.routeObj.route === mismatchedRoute.routeObj.route\n        );\n        if (mismatchedRouteExistsInMatchedList) {\n          mismatchingRoutes.splice(mismatchedIndex, 1);\n        }\n      });\n\n      return {\n        matching: matchingRoutes,\n        mismatching: mismatchingRoutes.filter(Boolean),\n        path,\n        query,\n      };\n    },\n    target: recalculated,\n  });\n\n  $path.on(historyUpdateTriggered, (_, { path }) => path);\n\n  $query.on(historyUpdateTriggered, (_, { query }) => query);\n\n  const matchingRecalculated = recalculated.map(({ matching }) => matching);\n\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length > 0,\n    target: routesMatched,\n  });\n\n  sample({\n    clock: recalculated.map(({ mismatching }) => mismatching),\n    filter: (routes) => routes.length > 0,\n    target: routesMismatched,\n  });\n\n  $activeRoutes.on(recalculated, (_, { matching }) =>\n    matching.map((recheckResult) => recheckResult.routeObj.route)\n  );\n\n  /// Handling 404\n  sample({\n    clock: matchingRecalculated,\n    filter: (routes) => routes.length === 0,\n    target: routeNotFound,\n  });\n\n  if (isRoute(notFoundRoute)) {\n    sample({\n      clock: routeNotFound,\n      source: $query,\n      filter: notFoundRoute.$isOpened,\n      fn: (query) => ({ query, params: {} }),\n      target: notFoundRoute.updated,\n    });\n\n    sample({\n      clock: routeNotFound,\n      source: { query: $query, isOpened: notFoundRoute.$isOpened },\n      filter: ({ isOpened }) => !isOpened,\n      fn: ({ query }) => ({ query, params: {} }),\n      target: notFoundRoute.opened,\n    });\n\n    sample({\n      clock: matchingRecalculated,\n      source: notFoundRoute.$isOpened,\n      filter: (isOpened, matching) => isOpened && matching.length > 0,\n      target: notFoundRoute.closed,\n    });\n  }\n\n  /// Back/forward navigation\n  sample({\n    clock: controls.back,\n    source: $history,\n    target: historyBackFx,\n  });\n\n  sample({\n    clock: controls.forward,\n    source: $history,\n    target: historyForwardFx,\n  });\n\n  /// Query syncing\n  sample({\n    clock: $query,\n    source: { controlsQuery: controls.$query, localQuery: $query },\n    filter: ({ controlsQuery, localQuery }) =>\n      !paramsEqual(controlsQuery, localQuery),\n    fn: ({ localQuery }) => localQuery,\n    target: controls.$query,\n  });\n\n  sample({\n    clock: controls.$query,\n    source: {\n      path: $path,\n      localQuery: $query,\n      isNavigateInProgress: $isRouteNavigateInProgress,\n      realHistory: $history,\n    },\n    filter: ({ localQuery, isNavigateInProgress, realHistory }, query) => {\n      const realQuery =\n        serialize?.read(realHistory?.location.search ?? '') ??\n        Object.fromEntries(\n          new URLSearchParams(realHistory?.location.search ?? '')\n        );\n      return (\n        isNavigateInProgress ||\n        !paramsEqual(query, realQuery) ||\n        !paramsEqual(localQuery, query)\n      );\n    },\n    fn({ path }, query) {\n      const qs = serialize?.write(query) ?? new URLSearchParams(query);\n      return {\n        path: `${path}${qs ? `?${qs}` : ''}`,\n        params: {},\n        query: query,\n        method: 'push' as const,\n      };\n    },\n    target: pushFx,\n  });\n\n  /// Initialization\n  sample({\n    clock: recalculated,\n    source: {\n      activeRoutes: $activeRoutes,\n      path: $path,\n      query: $query,\n    },\n    filter: $isFirstCheckPassed.map(\n      (isFirstCheckPassed) => !isFirstCheckPassed\n    ),\n    target: initialized,\n  });\n\n  $isFirstCheckPassed.on(initialized, () => true).reset($history);\n\n  return {\n    $path,\n    $activeRoutes,\n    $history,\n    setHistory,\n    $query: $query,\n    back: controls.back,\n    forward: controls.forward,\n    push: pushFx,\n    routes: remappedRoutes,\n    initialized,\n    routeNotFound,\n  };\n}\n\ntype RecalculationResult<Params extends RouteParams> = {\n  routeObj: RouteObject<Params>;\n  params: Params;\n  query: RouteQuery;\n};\n\nconst containsCurrentRoute =\n  (routeObj: RouteObject<any>) =>\n  (recheckResults: RecalculationResult<any>[]) => {\n    const recheck = recheckResults.find(\n      (recheckResult) => recheckResult.routeObj.route === routeObj.route\n    );\n    if (!recheck) {\n      return;\n    }\n    return {\n      params: recheck.params,\n      query: recheck.query,\n    };\n  };\n","import { UnmappedRouteObject, RouteObject } from '../types';\n\nexport function remapRouteObjects(\n  objects: UnmappedRouteObject<any>[],\n  basePath: string = ''\n) {\n  let next: RouteObject<any>[] = [];\n  for (const routeObj of objects) {\n    if (Array.isArray(routeObj.route)) {\n      next.push(...routeObj.route.map((route) => ({ ...routeObj, route })));\n    } else {\n      // @ts-expect-error\n      next.push(routeObj);\n    }\n  }\n  next = next.map((routeObj) => ({\n    ...routeObj,\n    path: `${basePath}${routeObj.path}`,\n  }));\n  const derivedRoutes: RouteObject<any>[] = [];\n  const nonDerivedRoutes: RouteObject<any>[] = [];\n  for (const routeObj of next) {\n    // @ts-expect-error Internals\n    if (routeObj.route.settings.derived) {\n      derivedRoutes.push(routeObj);\n    } else {\n      nonDerivedRoutes.push(routeObj);\n    }\n  }\n  if (derivedRoutes.length) {\n    for (const derivedRoute of derivedRoutes) {\n      console.error(\n        `createHistoryRouter: ${derivedRoute.path} uses derived route. This won't work`\n      );\n    }\n  }\n  return nonDerivedRoutes;\n}\n","import {\n  Clock,\n  createEvent,\n  createStore,\n  Event,\n  is,\n  sample,\n  Store,\n} from 'effector';\nimport { EmptyObject, RouteInstance, RouteParams, RouteQuery } from '../types';\n\ntype RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject\n  ? {\n      clock?: Clock<T>;\n      route: RouteInstance<Params>;\n      query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n      replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n    }\n  :\n      | {\n          clock?: Clock<T>;\n          route: RouteInstance<Params>;\n          params: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        }\n      | {\n          clock?: Clock<{\n            params: Params;\n            query?: RouteQuery;\n            replace?: boolean;\n          }>;\n          route: RouteInstance<Params>;\n          params?: ((clock: T) => Params) | Store<Params> | Params;\n          query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;\n          replace?: ((clock: T) => boolean) | Store<boolean> | boolean;\n        };\n\n/** Opens passed `route` upon `clock` trigger */\nexport function redirect<T, Params extends RouteParams>(\n  options: RedirectParams<T, Params>\n) {\n  const clock = options.clock\n    ? sample({ clock: options.clock as Event<T> })\n    : createEvent<T>();\n\n  let params = toStore(options.params || {});\n  let query = toStore(options.query || {});\n  // @ts-expect-error\n  let replace = toStore(options.replace || false);\n\n  sample({\n    clock: clock,\n    source: { params, query, replace },\n    fn: ({ params, query, replace }, clock) => ({\n      params: typeof params === 'function' ? params(clock) : params,\n      query: typeof query === 'function' ? query(clock) : query,\n      replace: typeof replace === 'function' ? replace(clock) : replace,\n    }),\n    target: options.route.navigate,\n  });\n  return clock;\n}\n\nfunction toStore<T>(payload: T | Store<T>): Store<T> {\n  return is.store(payload) ? payload : createStore(payload as T);\n}\n","import {\n  is,\n  guard,\n  merge,\n  sample,\n  combine,\n  createStore,\n  Unit,\n  Clock,\n  Effect,\n  StoreValue,\n  createEvent,\n  NoInfer,\n  EffectParams,\n  attach,\n} from 'effector';\n\nimport { createRoute } from './create-route';\nimport {\n  RouteInstance,\n  RouteParams,\n  RouteParamsAndQuery,\n  RouteQuery,\n} from '../types';\n\nimport { isRoute } from './is-route';\n\ntype ChainRouteParamsInternalAttach<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: {\n    effect: FX;\n    mapParams: ({\n      params,\n      query,\n    }: {\n      params: Params;\n      query: RouteQuery;\n    }) => NoInfer<EffectParams<FX>>;\n  };\n  openOn?: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsWithEffect<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;\n};\n\ntype ChainRouteParamsAdvanced<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute?: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn?: Clock<any>;\n};\n\ntype ChainRouteParamsNormalized<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  chainedRoute: RouteInstance<Params>;\n  beforeOpen: Clock<RouteParamsAndQuery<Params>>;\n  openOn: Clock<any>;\n  cancelOn: Clock<any>;\n};\n\ntype chainRouteParams<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n> =\n  | RouteInstance<Params>\n  | ChainRouteParamsWithEffect<Params>\n  | ChainRouteParamsAdvanced<Params>\n  | ChainRouteParamsInternalAttach<Params, FX>;\n\nfunction normalizeChainRouteParams<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(params: chainRouteParams<Params, FX>): ChainRouteParamsNormalized<Params> {\n  const resultParams: ChainRouteParamsNormalized<Params> =\n    {} as ChainRouteParamsNormalized<Params>;\n  if (isRoute(params)) {\n    Object.assign(resultParams, {\n      route: params,\n      chainedRoute: createRoute<Params>(),\n      beforeOpen: createEvent(),\n      openOn: merge([params.opened, params.closed]),\n      cancelOn: merge([createEvent()]),\n    });\n    return resultParams;\n  }\n  const effectParams = params as ChainRouteParamsWithEffect<Params>;\n  Object.assign(resultParams, {\n    route: effectParams.route,\n    chainedRoute: effectParams.chainedRoute || createRoute<Params>(),\n    beforeOpen: is.unit(effectParams.beforeOpen)\n      ? effectParams.beforeOpen\n      : attach(effectParams.beforeOpen),\n  });\n  if (is.effect(resultParams.beforeOpen)) {\n    Object.assign(resultParams, {\n      openOn:\n        // @ts-expect-error\n        effectParams.openOn || resultParams.beforeOpen.doneData,\n      cancelOn:\n        // @ts-expect-error\n        effectParams.cancelOn || resultParams.beforeOpen.failData,\n    });\n    return resultParams;\n  }\n  const advancedParams = params as ChainRouteParamsAdvanced<Params>;\n  Object.assign(resultParams, {\n    openOn: sample({ clock: advancedParams.openOn as Unit<any> }),\n    cancelOn: sample({\n      clock: (advancedParams.cancelOn as Unit<any>) || createEvent(),\n    }),\n  });\n  return resultParams;\n}\n\nfunction chainRoute<Params extends RouteParams>(\n  instance: RouteInstance<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsWithEffect<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<Params extends RouteParams>(\n  config: ChainRouteParamsAdvanced<Params>\n): RouteInstance<Params>;\n\nfunction chainRoute<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(config: ChainRouteParamsInternalAttach<Params, FX>): RouteInstance<Params>;\n\n/**\n * Creates chained route\n * @link https://github.com/Kelin2025/atomic-router/issues/10\n * @param {RouteInstance<any>} params.route - Route to listen\n * @param {RouteInstance<any>} [params.chainedRoute]  - Route to be created\n * @param {Clock<any>} params.beforeOpen - Will be triggered when `params.route` open\n * @param {Clock<any>} params.openOn - Will open `chainedRoute` if `params.route` is still opened\n * @param {Clock<any>} params.cancelOn - Cancels chain\n * @returns {RouteInstance<any>} `chainedRoute`\n */\nfunction chainRoute<\n  Params extends RouteParams,\n  FX extends Effect<any, any, any>\n>(params: chainRouteParams<Params, FX>) {\n  const { route, chainedRoute, beforeOpen, openOn, cancelOn } =\n    normalizeChainRouteParams(params);\n  const $params = createStore({} as StoreValue<typeof route['$params']>);\n  const $query = createStore({} as StoreValue<typeof route['$query']>);\n  const $hasSameParams = combine(\n    combine([route.$params, route.$query]),\n    combine([$params, $query]),\n    (current, stored) => {\n      return current[0] === stored[0] && current[1] === stored[1];\n    }\n  );\n  const routeOpened = sample({\n    clock: [route.opened, route.updated],\n  });\n  // 1. Call `beforeOpen` whenever route is opened\n  sample({\n    clock: routeOpened,\n    target: beforeOpen as Unit<RouteParamsAndQuery<any>>,\n  });\n  $params.on(routeOpened, (_prev, { params }) => params);\n  $query.on(routeOpened, (_prev, { query }) => query);\n  // 2. Listen to `openOn` if route is still opened on the same position\n  const chainedRouteResolved = guard({\n    clock: openOn,\n    source: { params: $params, query: $query },\n    filter: $hasSameParams,\n  });\n  sample({\n    clock: chainedRouteResolved,\n    target: chainedRoute.navigate,\n  });\n  // 4. Cancel loading if page closed or `cancelOn` is called\n  // @ts-expect-error\n  const aborted = merge([route.closed, cancelOn]);\n  $params.reset(aborted);\n  $query.reset(aborted);\n  sample({\n    clock: aborted,\n    target: chainedRoute.closed,\n  });\n  return chainedRoute;\n}\n\n// This is written separately to correctly export all type overloads\nexport { chainRoute };\n","import { Clock, combine, createStore, sample, Store, Unit } from 'effector';\n\nimport { RouteInstance, RouteQuery } from '../types';\nimport { createRouterControls } from './create-router-controls';\n\ntype QueryCleanupStrategy = {\n  irrelevant: boolean;\n  empty: boolean;\n  preserve: string[];\n};\n\ntype QuerySyncParams<T extends Record<string, Store<any>>> = {\n  source: T;\n  clock?: Clock<any>;\n  controls: ReturnType<typeof createRouterControls>;\n  route?: RouteInstance<any>;\n  cleanup?: boolean | Partial<QueryCleanupStrategy>;\n};\n\nexport function querySync<T extends Record<string, Store<any>>>(\n  params: QuerySyncParams<T>\n) {\n  const $isOpened = params.route?.$isOpened ?? createStore(true);\n  const $source = combine(params.source);\n  const clock = (params.clock ?? $source) as Unit<any>;\n  const cleanupStrategy = !('cleanup' in params)\n    ? cleanupStrategies.default\n    : typeof params.cleanup === 'boolean'\n    ? cleanupStrategies[params.cleanup ? 'all' : 'none']\n    : { ...cleanupStrategies.default, ...params.cleanup! };\n\n  const queryUpdatedFromHistory = sample({\n    clock: params.controls.$query,\n    filter: $isOpened,\n  });\n\n  sample({\n    clock,\n    source: combine([$source, params.controls.$query]),\n    filter: $isOpened,\n    fn: ([source, currentQuery]) => {\n      let nextQuery: RouteQuery = {};\n      if (cleanupStrategy.irrelevant) {\n        for (const key of cleanupStrategy.preserve) {\n          if (key in currentQuery) {\n            nextQuery[key] = currentQuery[key];\n          }\n        }\n      } else {\n        nextQuery = { ...currentQuery };\n      }\n      for (const key in source) {\n        nextQuery[key] = source[key];\n      }\n      if (cleanupStrategy.empty) {\n        for (const key in source) {\n          if (!cleanupStrategy.preserve.includes(key) && !nextQuery[key]) {\n            delete nextQuery[key];\n          }\n        }\n      }\n      return nextQuery as RouteQuery;\n    },\n    target: params.controls.$query,\n  });\n\n  for (const k in params.source) {\n    const $queryParam = params.source[k as keyof typeof params.source];\n    $queryParam.on(queryUpdatedFromHistory, (_, query) => {\n      return query[k] ?? $queryParam.defaultState;\n    });\n  }\n}\n\nconst cleanupStrategies = {\n  all: {\n    irrelevant: true,\n    empty: true,\n    preserve: [],\n  },\n  default: {\n    irrelevant: false,\n    empty: true,\n    preserve: [],\n  },\n  none: {\n    irrelevant: false,\n    empty: false,\n    preserve: [],\n  },\n};\n","import { History } from 'history';\nimport { Effect, Event, Store } from 'effector';\n\nexport type RouteParams = Record<string, any>;\n\nexport type RouteQuery = Record<string, any>;\n\nexport type RouteParamsAndQuery<Params extends RouteParams> = {\n  params: Params;\n  query: RouteQuery;\n};\n\nexport interface NavigateParams<Params extends RouteParams>\n  extends RouteParamsAndQuery<Params> {\n  replace?: boolean;\n}\n\nexport type RouteInstance<Params extends RouteParams> = {\n  $isOpened: Store<boolean>;\n  $params: Store<Params>;\n  $query: Store<RouteQuery>;\n  opened: Event<RouteParamsAndQuery<Params>>;\n  updated: Event<RouteParamsAndQuery<Params>>;\n  closed: Event<void>;\n  navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;\n  open: Effect<\n    Params extends EmptyObject ? void : Params,\n    RouteParamsAndQuery<Params>\n  >;\n  kind: typeof Kind.ROUTE;\n};\n\nexport type RouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params>;\n  path: string;\n};\n\nexport type UnmappedRouteObject<Params extends RouteParams> = {\n  route: RouteInstance<Params> | RouteInstance<Params>[];\n  path: string;\n};\n\nexport type HistoryPushParams = {\n  history: History;\n  path: string;\n  params: RouteParams;\n  query: RouteQuery;\n  method: 'replace' | 'push';\n};\n\nexport type HistoryBackForwardParams = History;\n\nexport type ParamsSerializer = {\n  write: (params: RouteParams) => string;\n  read: (query: string) => RouteParams;\n};\n\n// @ts-expect-error\nexport type PathCreator<Params extends RouteParams> = string;\n\nexport const Kind = {\n  ROUTE: Symbol(),\n};\n\nexport type EmptyObject = { [key in string]: never };\n","import { createEvent, createStore } from 'effector';\n\nimport { RouteQuery } from '../types';\nimport { paramsEqual } from '../utils/equals';\n\nexport const createRouterControls = () => {\n  return {\n    $query: createStore<RouteQuery>(\n      {},\n      {\n        updateFilter: (update, current) => !paramsEqual(current, update),\n      }\n    ),\n    back: createEvent(),\n    forward: createEvent(),\n  };\n};\n","import { Kind, RouteInstance } from '../types';\n\n/** Detects whether passed value is a `RouteInstance<any>` or not */\nexport const isRoute = (\n  route: RouteInstance<any> | unknown\n): route is RouteInstance<any> => {\n  return (\n    typeof route === 'object' &&\n    route !== null &&\n    'kind' in route &&\n    // @ts-expect-error\n    route.kind === Kind.ROUTE\n  );\n};\n"],"names":["createRoute","params","navigateFx","createEffect","_ref","_ref$replace","replace","query","name","sid","openFx","attach","and","effect","mapParams","or","$isOpened","createStore","$params","$query","opened","createEvent","updated","closed","on","_","_ref2","_ref3","_ref4","_ref5","split","source","doneData","match","map","isOpened","cases","navigate","open","kind","Kind","ROUTE","settings","derived","Boolean","filter","paramsEqual","a","b","Object","keys","length","k","buildPath","_serialize$write","serialize","pathname","compile","pathCreator","serializedParams","write","URLSearchParams","matchPath","actualPath","matches","path","url","URL","hash","join","getComparablePath","assertHistory","history","Error","not","value","createHistoryRouter","base","routes","notFoundRoute","hydrate","_ref$controls","controls","_withFactory","fn","createRouterControls","method","remappedRoutes","objects","basePath","_step","next","_loop","_next","routeObj","Array","isArray","route","push","_objectSpread","_iterator","_createForOfIteratorHelperLoose","done","_step2","derivedRoutes","nonDerivedRoutes","_iterator2","_step3","_iterator3","console","error","derivedRoute","remapRouteObjects","setHistory","navigateFromRouteTriggered","historyUpdated","recalculateTriggered","recalculated","routesMatched","routesMismatched","routeNotFound","initialized","$path","updateFilter","newQuery","oldQuery","$activeRoutes","$history","$isFirstCheckPassed","$isRouteNavigateInProgress","pushFx","historyPushFx","subscribeHistoryFx","scopedHistoryUpdated","scopeBind","err","listen","historyUpdatedParsed","sample","clock","_serialize$read","location","read","search","fromEntries","historyUpdateTriggered","target","_serialize$read2","currentRouteMatched","filterMap","containsCurrentRoute","currentRouteMismatched","routeStateChangeRequested","_ref16","paramsAndQuery","_ref17","reset","matchingRoutes","mismatchingRoutes","includes","_matchPath","forEach","mismatchedRoute","mismatchedIndex","some","matchedRoute","splice","matching","mismatching","_ref6","matchingRecalculated","_ref7","_ref8","_ref9","recheckResult","isRoute","_ref10","_ref11","back","historyBackFx","forward","historyForwardFx","controlsQuery","localQuery","_ref12","_ref13","isNavigateInProgress","realHistory","_serialize$read3","_realHistory$location","_realHistory$location2","realQuery","_ref15","qs","activeRoutes","isFirstCheckPassed","redirect","options","toStore","payload","is","store","chainRoute","normalizeChainRouteParams","resultParams","assign","chainedRoute","beforeOpen","openOn","merge","cancelOn","effectParams","unit","failData","advancedParams","$hasSameParams","combine","current","stored","routeOpened","_prev","chainedRouteResolved","guard","aborted","querySync","_params$route$$isOpen","_params$route","_params$clock","$source","cleanupStrategy","cleanup","cleanupStrategies","queryUpdatedFromHistory","currentQuery","nextQuery","irrelevant","preserve","key","empty","$queryParam","_query$k","defaultState","Symbol","update","recheckResults","recheck","find","all","default","none"],"mappings":"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"}