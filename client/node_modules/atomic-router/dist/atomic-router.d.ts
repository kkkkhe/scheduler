import * as effector from 'effector';
import { Store, Event, Effect, Clock, NoInfer, EffectParams } from 'effector';
import { History } from 'history';

declare type RouteParams = Record<string, any>;
declare type RouteQuery = Record<string, any>;
declare type RouteParamsAndQuery<Params extends RouteParams> = {
    params: Params;
    query: RouteQuery;
};
interface NavigateParams<Params extends RouteParams> extends RouteParamsAndQuery<Params> {
    replace?: boolean;
}
declare type RouteInstance<Params extends RouteParams> = {
    $isOpened: Store<boolean>;
    $params: Store<Params>;
    $query: Store<RouteQuery>;
    opened: Event<RouteParamsAndQuery<Params>>;
    updated: Event<RouteParamsAndQuery<Params>>;
    closed: Event<void>;
    navigate: Effect<NavigateParams<Params>, NavigateParams<Params>>;
    open: Effect<Params extends EmptyObject ? void : Params, RouteParamsAndQuery<Params>>;
    kind: typeof Kind.ROUTE;
};
declare type RouteObject<Params extends RouteParams> = {
    route: RouteInstance<Params>;
    path: string;
};
declare type UnmappedRouteObject<Params extends RouteParams> = {
    route: RouteInstance<Params> | RouteInstance<Params>[];
    path: string;
};
declare type HistoryPushParams = {
    history: History;
    path: string;
    params: RouteParams;
    query: RouteQuery;
    method: 'replace' | 'push';
};
declare type HistoryBackForwardParams = History;
declare type ParamsSerializer = {
    write: (params: RouteParams) => string;
    read: (query: string) => RouteParams;
};
declare type PathCreator<Params extends RouteParams> = string;
declare const Kind: {
    ROUTE: symbol;
};
declare type EmptyObject = {
    [key in string]: never;
};

declare type CreateRouteParams = {
    filter?: Store<boolean>;
};
declare function createRoute<Params extends RouteParams = {}>(params?: CreateRouteParams): RouteInstance<Params>;

declare const createRouterControls: () => {
    $query: effector.Store<RouteQuery>;
    back: effector.Event<void>;
    forward: effector.Event<void>;
};

declare function createHistoryRouter({ base, routes, notFoundRoute, hydrate, serialize, controls, }: {
    base?: string;
    routes: UnmappedRouteObject<any>[];
    notFoundRoute?: RouteInstance<any>;
    serialize?: ParamsSerializer;
    hydrate?: boolean;
    controls?: ReturnType<typeof createRouterControls>;
}): {
    $path: effector.Store<string>;
    $activeRoutes: effector.Store<RouteInstance<any>[]>;
    $history: effector.Store<History>;
    setHistory: effector.Event<History>;
    $query: effector.Store<RouteQuery>;
    back: effector.Event<void>;
    forward: effector.Event<void>;
    push: effector.Effect<Omit<HistoryPushParams, "history">, HistoryPushParams, Error>;
    routes: RouteObject<any>[];
    initialized: effector.Event<{
        activeRoutes: RouteInstance<any>[];
        path: string;
        query: RouteQuery;
    }>;
    routeNotFound: effector.Event<void>;
};

declare type BuildPathParams<Params extends RouteParams> = {
    pathCreator: PathCreator<Params>;
    params: Params;
    query: RouteQuery;
    serialize?: ParamsSerializer;
};
declare function buildPath<Params extends RouteParams>({ pathCreator, params, query, serialize, }: BuildPathParams<Params>): string;
declare type MatchPathParams<Params extends RouteParams> = {
    pathCreator: PathCreator<Params>;
    actualPath: string;
};
declare function matchPath<Params extends RouteParams>({ pathCreator, actualPath, }: MatchPathParams<Params>): {
    readonly matches: true;
    readonly params: object;
} | {
    readonly matches: false;
    readonly params?: undefined;
};

/** Detects whether passed value is a `RouteInstance<any>` or not */
declare const isRoute: (route: RouteInstance<any> | unknown) => route is RouteInstance<any>;

declare type RedirectParams<T, Params extends RouteParams> = Params extends EmptyObject ? {
    clock?: Clock<T>;
    route: RouteInstance<Params>;
    query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;
    replace?: ((clock: T) => boolean) | Store<boolean> | boolean;
} : {
    clock?: Clock<T>;
    route: RouteInstance<Params>;
    params: ((clock: T) => Params) | Store<Params> | Params;
    query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;
    replace?: ((clock: T) => boolean) | Store<boolean> | boolean;
} | {
    clock?: Clock<{
        params: Params;
        query?: RouteQuery;
        replace?: boolean;
    }>;
    route: RouteInstance<Params>;
    params?: ((clock: T) => Params) | Store<Params> | Params;
    query?: ((clock: T) => RouteQuery) | Store<RouteQuery> | RouteQuery;
    replace?: ((clock: T) => boolean) | Store<boolean> | boolean;
};
/** Opens passed `route` upon `clock` trigger */
declare function redirect<T, Params extends RouteParams>(options: RedirectParams<T, Params>): Event<T>;

declare type ChainRouteParamsInternalAttach<Params extends RouteParams, FX extends Effect<any, any, any>> = {
    route: RouteInstance<Params>;
    chainedRoute?: RouteInstance<Params>;
    beforeOpen: {
        effect: FX;
        mapParams: ({ params, query, }: {
            params: Params;
            query: RouteQuery;
        }) => NoInfer<EffectParams<FX>>;
    };
    openOn?: Clock<any>;
    cancelOn?: Clock<any>;
};
declare type ChainRouteParamsWithEffect<Params extends RouteParams> = {
    route: RouteInstance<Params>;
    chainedRoute?: RouteInstance<Params>;
    beforeOpen: Effect<RouteParamsAndQuery<Params>, any, any>;
};
declare type ChainRouteParamsAdvanced<Params extends RouteParams> = {
    route: RouteInstance<Params>;
    chainedRoute?: RouteInstance<Params>;
    beforeOpen: Clock<RouteParamsAndQuery<Params>>;
    openOn: Clock<any>;
    cancelOn?: Clock<any>;
};
declare function chainRoute<Params extends RouteParams>(instance: RouteInstance<Params>): RouteInstance<Params>;
declare function chainRoute<Params extends RouteParams>(config: ChainRouteParamsWithEffect<Params>): RouteInstance<Params>;
declare function chainRoute<Params extends RouteParams>(config: ChainRouteParamsAdvanced<Params>): RouteInstance<Params>;
declare function chainRoute<Params extends RouteParams, FX extends Effect<any, any, any>>(config: ChainRouteParamsInternalAttach<Params, FX>): RouteInstance<Params>;

declare type QueryCleanupStrategy = {
    irrelevant: boolean;
    empty: boolean;
    preserve: string[];
};
declare type QuerySyncParams<T extends Record<string, Store<any>>> = {
    source: T;
    clock?: Clock<any>;
    controls: ReturnType<typeof createRouterControls>;
    route?: RouteInstance<any>;
    cleanup?: boolean | Partial<QueryCleanupStrategy>;
};
declare function querySync<T extends Record<string, Store<any>>>(params: QuerySyncParams<T>): void;

export { EmptyObject, HistoryBackForwardParams, HistoryPushParams, Kind, NavigateParams, ParamsSerializer, PathCreator, RouteInstance, RouteObject, RouteParams, RouteParamsAndQuery, RouteQuery, UnmappedRouteObject, buildPath, chainRoute, createHistoryRouter, createRoute, createRouterControls, isRoute, matchPath, querySync, redirect };
